<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseToolMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JLink Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">ru.akman.maven.plugins</a> &gt; <span class="el_source">BaseToolMojo.java</span></div><h1>BaseToolMojo.java</h1><pre class="source lang-java linenums">/*
  Copyright (C) 2020 Alexander Kapitman

  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

package ru.akman.maven.plugins;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.JavaVersion;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.BuildPluginManager;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.shared.model.fileset.util.FileSetManager;
import org.apache.maven.toolchain.Toolchain;
import org.apache.maven.toolchain.ToolchainManager;
import org.codehaus.plexus.util.cli.CommandLineException;
import org.codehaus.plexus.util.cli.CommandLineUtils;
import org.codehaus.plexus.util.cli.Commandline;

/**
 * Base class for creating a CLI tool Mojos.
 */
<span class="fc" id="L53">public abstract class BaseToolMojo extends AbstractMojo {</span>

  /**
   * The name of JDK toolchain.
   */
  private static final String JDK = &quot;jdk&quot;;

  /**
   * The name of the system environment JAVA_HOME variable.
   */
  private static final String JAVA_HOME = &quot;JAVA_HOME&quot;;

  /**
   * The value for older major versions of Java.
   */
  private static final int OLD_MAJOR = 1;

  /**
   * The value from which new major versions of Java begin.
   */
  private static final int NEW_MAJOR = 9;

  /**
   * The name of the subdirectory under JAVA_HOME where executables live.
   */
  private static final String JAVA_HOME_BIN = &quot;bin&quot;;

  /**
   * The name of the system environment PATH variable.
   */
  private static final String PATH = &quot;PATH&quot;;

  /**
   * The name of the system environment PATHEXT variable.
   */
  private static final String PATHEXT = &quot;PATHEXT&quot;;

  /**
   * The version string pattern of CLI tool.
   */
  private static final String VERSION_PATTERN = &quot;^(\\d+)\\.(\\d+).*&quot;;

  /**
   * The version option of CLI tool.
   */
  private static final String VERSION_OPTION = &quot;--version&quot;;

  /**
   * Project base directory (that containing the pom.xml file).
   */
  protected File baseDir;

  /**
   * Project build directory (${project.basedir}/target).
   */
  protected File buildDir;

  /**
   * Project output directory (${project.build.directory}/classes).
   */
  protected File outputDir;

  /**
   * Project properties.
   */
  protected Properties properties;

  /**
   * Default charset (${project.build.sourceEncoding}).
   */
<span class="fc" id="L123">  protected Charset sourceEncoding = Charset.defaultCharset();</span>

  /**
   * Fileset manager.
   */
  protected FileSetManager fileSetManager;

  /**
   * All JDK toolchains available in user settings
   * independently from maven-toolchains-plugin.
   */
  protected List&lt;Toolchain&gt; toolchains;

  /**
   * JDK toolchain from build context,
   * i.e. the toolchain selected by maven-toolchains-plugin.
   */
  protected Toolchain toolchain;

  /**
   * Tool home directory.
   */
  protected File toolHomeDir;

  /**
   * Tool executable.
   */
  protected File toolExecutable;

  /**
   * Tool version.
   */
  protected String toolVersion;

  /**
   * Tool corresponding java version.
   */
  protected JavaVersion toolJavaVersion;

  /**
   * Toolchain manager.
   */
  @Component
  protected ToolchainManager toolchainManager;

  /**
   * Build plugin manager.
   */
  @Component
  protected BuildPluginManager pluginManager;

  /**
   * Maven project.
   */
  @Parameter(
      defaultValue = &quot;${project}&quot;,
      readonly = true,
      required = true
  )
  protected MavenProject project;

  /**
   * Maven session.
   */
  @Parameter(
      defaultValue = &quot;${session}&quot;,
      readonly = true,
      required = true
  )
  protected MavenSession session;

  /**
   * Get tool executable path from tool home.
   *
   * @param toolName the name of the tool (without extension)
   * @param toolHomeDir the tool home directory
   * @param toolBinDirName the name of subdirectory where the tool live
   *
   * @return tool executable path from tool home directory specified in
   *         configuration as toolhome parameter or null
   */
  private Path getExecutableFromToolHome(final String toolName,
      final File toolHomeDir, final String toolBinDirName) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">    Path executablePath = toolHomeDir == null</span>
<span class="nc" id="L207">        ? null</span>
<span class="nc" id="L208">        : resolveToolPath(toolName, toolHomeDir.toPath(), toolBinDirName);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (executablePath != null) {</span>
      try {
<span class="nc" id="L211">        executablePath = executablePath.toRealPath();</span>
<span class="nc" id="L212">        this.toolHomeDir = toolHomeDir;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L214">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (toolhome) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L217">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (toolhome) for [{0}]: {1}&quot;, toolName,
              this.toolHomeDir));
        }
<span class="nc" id="L221">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L223">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (toolhome) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L227">      }</span>
    }
<span class="nc" id="L229">    return executablePath;</span>
  }

  /**
   * Get tool executable path from default JDK toolchain.
   *
   * @param toolName the name of the tool (without extension)
   *
   * @return tool executable path from JDK toolchain specified in
   *         configuration by toolchain plugin or null
   */
  @SuppressWarnings(&quot;deprecation&quot;) // DefaultJavaToolChain
  private Path getExecutableFromToolchain(final String toolName) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">    final String tcJavaHome = toolchain == null</span>
<span class="nc" id="L243">        ? null</span>
<span class="nc" id="L244">        : org.apache.maven.toolchain.java.DefaultJavaToolChain.class.cast(</span>
<span class="nc" id="L245">            toolchain).getJavaHome();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    final String tcToolExecutable = toolchain == null</span>
<span class="nc" id="L247">        ? null</span>
<span class="nc" id="L248">        : toolchain.findTool(toolName);</span>
<span class="nc" id="L249">    Path executablePath = null;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    if (!StringUtils.isBlank(tcJavaHome)</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        &amp;&amp; !StringUtils.isBlank(tcToolExecutable)) {</span>
      try {
<span class="nc" id="L253">        executablePath = Paths.get(tcToolExecutable).toRealPath();</span>
<span class="nc" id="L254">        this.toolHomeDir = new File(tcJavaHome);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L256">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (toolchain) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L259">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (toolchain) for [{0}]: {1}&quot;, toolName,
              this.toolHomeDir));
        }
<span class="nc" id="L263">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L265">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (toolchain) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L269">      }</span>
    }
<span class="nc" id="L271">    return executablePath;</span>
  }

  /**
   * Get tool executable path from java home.
   *
   * @param toolName the name of the tool (without extension)
   *
   * @return tool executable path from JDK home directory specified in
   *              the system environment variable JAVA_HOME or null
   */
  private Path getExecutableFromJavaHome(final String toolName) {
<span class="nc" id="L283">    final File javaHomeDir = getJavaHome();</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">    Path executablePath = javaHomeDir == null</span>
<span class="nc" id="L285">        ? null</span>
<span class="nc" id="L286">        : resolveToolPath(toolName, javaHomeDir.toPath(), JAVA_HOME_BIN);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">    if (executablePath != null) {</span>
      try {
<span class="nc" id="L289">        executablePath = executablePath.toRealPath();</span>
<span class="nc" id="L290">        this.toolHomeDir = javaHomeDir;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L292">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (javahome) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L295">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (javahome) for [{0}]: {1}&quot;, toolName,
              this.toolHomeDir));
        }
<span class="nc" id="L299">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L301">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (javahome) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L305">      }</span>
    }
<span class="nc" id="L307">    return executablePath;</span>
  }

  /**
   * Get tool executable path from system path.
   *
   * @param toolName the name of the tool (without extension)
   *
   * @return tool executable path from paths specified in
   *              the system environment variable PATH or null
   */
  private Path getExecutableFromSystemPath(final String toolName) {
<span class="nc" id="L319">    final List&lt;Path&gt; systemPath = getSystemPath();</span>
<span class="nc" id="L320">    Path executablePath = null;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">    for (final Path path : systemPath) {</span>
<span class="nc" id="L322">      executablePath = resolveToolPath(toolName, path, null);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (executablePath != null) {</span>
<span class="nc" id="L324">        break;</span>
      }
<span class="nc" id="L326">    }</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">    if (executablePath != null) {</span>
      try {
<span class="nc" id="L329">        final Path toolHomePath = executablePath.getParent();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        this.toolHomeDir = toolHomePath == null</span>
<span class="nc" id="L331">            ? null : toolHomePath.toRealPath().toFile();</span>
<span class="nc" id="L332">        executablePath = executablePath.toRealPath();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L334">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (systempath) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L337">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (systempath) for [{0}]: {1}&quot;, toolName,
              this.toolHomeDir));
        }
<span class="nc" id="L341">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L343">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (systempath) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L347">      }</span>
    }
<span class="nc" id="L349">    return executablePath;</span>
  }

  /**
   * Get tool executable path.
   *
   * &lt;p&gt;
   * Find tool executable in following order:
   * - toolhome (user specified tool home directory in configuration)
   * - toolchain (user specified JDK home directory by toolchains-plugin)
   * - javahome (JDK home directory specified by system variable JAVA_HOME)
   * - systempath (system path)
   * &lt;/p&gt;
   *
   * @param toolName the name of the tool (without extension)
   * @param toolHomeDir the tool home directory
   * @param toolBinDirName the name of subdirectory where the tool live
   *
   * @return tool executable path from tool home directory specified in
   *         configuration or by toolchain plugin or by system variable
   *         JAVA_HOME or null
   */
  private Path getToolExecutable(final String toolName, final File toolHomeDir,
      final String toolBinDirName) {
<span class="nc" id="L373">    Path executablePath =</span>
<span class="nc" id="L374">        getExecutableFromToolHome(toolName, toolHomeDir, toolBinDirName);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L376">      return executablePath;</span>
    }
<span class="nc bnc" id="L378" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L379">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (toolhome) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L382">    executablePath = getExecutableFromToolchain(toolName);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L384">      return executablePath;</span>
    }
<span class="nc bnc" id="L386" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L387">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (toolchain) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L390">    executablePath = getExecutableFromJavaHome(toolName);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L392">      return executablePath;</span>
    }
<span class="nc bnc" id="L394" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L395">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (javahome) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L398">    executablePath = getExecutableFromSystemPath(toolName);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L400">      return executablePath;</span>
    }
<span class="nc bnc" id="L402" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L403">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (systempath) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L406">    return executablePath;</span>
  }

  /**
   * Resolve the tool path against the specified home dir.
   *
   * @param toolName the name of the tool (without extension)
   * @param toolHomeDir the home path of the tool
   * @param toolBinDirName the name of subdirectory where the tool live
   *
   * @return tool executable path or null
   */
  private Path resolveToolPath(final String toolName, final Path toolHomeDir,
      final String toolBinDirName) {
<span class="nc bnc" id="L420" title="All 4 branches missed.">    if (toolHomeDir == null || StringUtils.isBlank(toolName)) {</span>
<span class="nc" id="L421">      return null;</span>
    }
<span class="nc" id="L423">    Path toolBinDir = toolHomeDir;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">    if (!StringUtils.isBlank(toolBinDirName)) {</span>
<span class="nc" id="L425">      toolBinDir = toolHomeDir.resolve(toolBinDirName);</span>
    }
<span class="nc bnc" id="L427" title="All 4 branches missed.">    if (!Files.exists(toolBinDir) || !Files.isDirectory(toolBinDir)) {</span>
<span class="nc" id="L428">      return null;</span>
    }
<span class="nc" id="L430">    return findToolExecutable(toolName, List.of(toolBinDir));</span>
  }

  /**
   * Find tool executable under specified paths.
   *
   * @param toolName the name of the tool (without extension)
   * @param paths the list of path under which the tool will be find
   *
   * @return tool executable path or null if it not found
   */
  private Path findToolExecutable(final String toolName,
      final List&lt;Path&gt; paths) {
<span class="nc" id="L443">    Path executablePath = null;</span>
<span class="nc" id="L444">    Path toolFile = null;</span>
<span class="nc" id="L445">    final List&lt;String&gt; exts = getPathExt();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">    for (final Path path : paths) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">      if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        for (final String ext : exts) {</span>
<span class="nc" id="L449">          toolFile = path.resolve(toolName.concat(ext));</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">          if (Files.isExecutable(toolFile)</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">              &amp;&amp; !Files.isDirectory(toolFile)) {</span>
<span class="nc" id="L452">            executablePath = toolFile;</span>
<span class="nc" id="L453">            break;</span>
          }
<span class="nc" id="L455">        }</span>
      } else {
<span class="nc" id="L457">        toolFile = path.resolve(toolName);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (Files.isExecutable(toolFile)</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            &amp;&amp; !Files.isDirectory(toolFile)) {</span>
<span class="nc" id="L460">          executablePath = toolFile;</span>
<span class="nc" id="L461">          break;</span>
        }
      }
<span class="nc" id="L464">    }</span>
<span class="nc" id="L465">    return executablePath;</span>
  }

  /**
   * Get path from the system environment variable JAVA_HOME.
   *
   * @return path from the system environment variable JAVA_HOME
   */
  private File getJavaHome() {
<span class="nc" id="L474">    final String javaHome = StringUtils.stripToEmpty(System.getenv(JAVA_HOME));</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">    return StringUtils.isBlank(javaHome) ? null : new File(javaHome);</span>
  }

  /**
   * Get list of the paths registered in the system environment variable PATH.
   *
   * @return list of the paths registered in the system
   *         environment variable PATH.
   */
  private List&lt;Path&gt; getSystemPath() {
<span class="nc" id="L485">    final String systemPath = StringUtils.stripToEmpty(System.getenv(PATH));</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">    if (StringUtils.isBlank(systemPath)) {</span>
<span class="nc" id="L487">      return new ArrayList&lt;Path&gt;();</span>
    }
<span class="nc" id="L489">    return Stream.of(systemPath.split(File.pathSeparator))</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        .filter(s -&gt; !StringUtils.isBlank(s))</span>
<span class="nc" id="L491">        .map(s -&gt; Paths.get(StringUtils.stripToEmpty(s)))</span>
<span class="nc" id="L492">        .collect(Collectors.toList());</span>
  }

  /**
   * Get list of the registered path extensions from
   * the system environment variable PATHEXT.
   *
   * @return list of the registered path extensions from the system
   *         environment variable PATHEXT
   */
  private List&lt;String&gt; getPathExt() {
<span class="nc bnc" id="L503" title="All 2 branches missed.">    if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc" id="L504">      final String systemPathExt =</span>
<span class="nc" id="L505">          StringUtils.stripToEmpty(System.getenv(PATHEXT));</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">      if (!StringUtils.isBlank(systemPathExt)) {</span>
<span class="nc" id="L507">        return Stream.of(systemPathExt.split(File.pathSeparator))</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">            .filter(s -&gt; !StringUtils.isBlank(s))</span>
<span class="nc" id="L509">            .map(s -&gt; StringUtils.stripToEmpty(s))</span>
<span class="nc" id="L510">            .collect(Collectors.toList());</span>
      }
    }
<span class="nc" id="L513">    return new ArrayList&lt;String&gt;();</span>
  }

  /**
   * Get the tool version.
   *
   * @return the tool version or null
   *
   * @throws CommandLineException if any errors occurred while processing
   *                              command line
   */
  private String getToolVersion(final Path executablePath)
      throws CommandLineException {
<span class="nc" id="L526">    final Commandline cmdLine = new Commandline();</span>
<span class="nc" id="L527">    cmdLine.setExecutable(executablePath.toString());</span>
<span class="nc" id="L528">    cmdLine.createArg().setValue(VERSION_OPTION);</span>
<span class="nc" id="L529">    final CommandLineUtils.StringStreamConsumer err =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L531">    final CommandLineUtils.StringStreamConsumer out =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L533">    final int exitCode =</span>
<span class="nc" id="L534">        CommandLineUtils.executeCommandLine(cmdLine, out, err);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">    return exitCode == 0</span>
<span class="nc" id="L536">        ? StringUtils.stripToEmpty(out.getOutput())</span>
<span class="nc" id="L537">            + StringUtils.stripToEmpty(err.getOutput())</span>
<span class="nc" id="L538">        : null;</span>
  }

  /**
   * Get Java version corresponding to the tool version passed in.
   *
   * @param version the tool version, not null
   *
   * @return the corresponding Java version matching the tool version
   */
  private JavaVersion getCorrespondingJavaVersion(final String version) {
<span class="nc" id="L549">    final Matcher versionMatcher = Pattern.compile(VERSION_PATTERN)</span>
<span class="nc" id="L550">        .matcher(version);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">    if (!versionMatcher.matches()) {</span>
<span class="nc" id="L552">      throw new IllegalArgumentException(&quot;Invalid version format&quot;);</span>
    }
<span class="nc" id="L554">    int majorVersion = 0;</span>
<span class="nc" id="L555">    int minorVersion = 0;</span>
    try {
<span class="nc" id="L557">      majorVersion = Integer.parseInt(versionMatcher.group(1));</span>
<span class="nc" id="L558">      minorVersion = Integer.parseInt(versionMatcher.group(2));</span>
<span class="nc" id="L559">    } catch (NumberFormatException ex) {</span>
<span class="nc" id="L560">      throw new IllegalArgumentException(&quot;Invalid version format&quot;, ex);</span>
<span class="nc" id="L561">    }</span>
<span class="nc" id="L562">    JavaVersion resolvedVersion = null;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if (majorVersion &gt;= NEW_MAJOR) {</span>
<span class="nc" id="L564">      resolvedVersion = JavaVersion.valueOf(&quot;JAVA_&quot; + majorVersion);</span>
    } else {
<span class="nc bnc" id="L566" title="All 2 branches missed.">      if (majorVersion == OLD_MAJOR) {</span>
<span class="nc" id="L567">        resolvedVersion = JavaVersion.valueOf(&quot;JAVA_&quot; + majorVersion</span>
            + &quot;_&quot; + minorVersion);
      } else {
<span class="nc" id="L570">        throw new IllegalArgumentException(&quot;Invalid version format&quot;);</span>
      }
    }
<span class="nc" id="L573">    return resolvedVersion;</span>
  }

  /**
   * Execute command line.
   *
   * @param cmdLine command line
   *
   * @return exit code
   *
   * @throws CommandLineException if any errors occurred while processing
   *                              command line
   */
  protected int execCmdLine(final Commandline cmdLine)
      throws CommandLineException {
<span class="nc bnc" id="L588" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L589">      getLog().debug(CommandLineUtils.toString(cmdLine.getCommandline()));</span>
    }
<span class="nc" id="L591">    final CommandLineUtils.StringStreamConsumer err =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L593">    final CommandLineUtils.StringStreamConsumer out =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L595">    final int exitCode = CommandLineUtils.executeCommandLine(cmdLine, out, err);</span>
<span class="nc" id="L596">    final String stdout = out.getOutput().trim();</span>
<span class="nc" id="L597">    final String stderr = err.getOutput().trim();</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">    if (exitCode == 0) {</span>
<span class="nc bnc" id="L599" title="All 4 branches missed.">      if (getLog().isInfoEnabled() &amp;&amp; !StringUtils.isBlank(stdout)) {</span>
<span class="nc" id="L600">        getLog().info(System.lineSeparator()</span>
<span class="nc" id="L601">            + System.lineSeparator()</span>
            + stdout);
      }
<span class="nc bnc" id="L604" title="All 4 branches missed.">      if (getLog().isInfoEnabled() &amp;&amp; !StringUtils.isBlank(stderr)) {</span>
<span class="nc" id="L605">        getLog().info(System.lineSeparator()</span>
<span class="nc" id="L606">            + System.lineSeparator()</span>
            + stderr);
      }
    } else {
<span class="nc bnc" id="L610" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (!StringUtils.isBlank(stdout)) {</span>
<span class="nc" id="L612">          getLog().error(System.lineSeparator()</span>
              + &quot;Exit code: &quot; + exitCode
<span class="nc" id="L614">              + System.lineSeparator() + stdout);</span>
        }
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (!StringUtils.isBlank(stderr)) {</span>
<span class="nc" id="L617">          getLog().error(System.lineSeparator()</span>
              + &quot;Exit code: &quot; + exitCode
<span class="nc" id="L619">              + System.lineSeparator() + stderr);</span>
        }
<span class="nc" id="L621">        getLog().error(System.lineSeparator()</span>
            + &quot;Command line was: &quot;
<span class="nc" id="L623">            + CommandLineUtils.toString(cmdLine.getCommandline()));</span>
      }
    }
<span class="nc" id="L626">    return exitCode;</span>
  }

  /**
   * Get JDK toolchain specified in toolchains-plugin for
   * current build context.
   *
   * @return JDK toolchain
   */
  @SuppressWarnings(&quot;deprecation&quot;) // DefaultJavaToolChain
  private Toolchain getDefaultJavaToolchain() {
<span class="nc" id="L637">    final Toolchain ctxToolchain =</span>
<span class="nc" id="L638">        toolchainManager.getToolchainFromBuildContext(JDK, session);</span>
<span class="nc bnc" id="L639" title="All 4 branches missed.">    return ctxToolchain == null || !(ctxToolchain</span>
        instanceof org.apache.maven.toolchain.java.DefaultJavaToolChain)
<span class="nc" id="L641">        ? null : ctxToolchain;</span>
  }

  /**
   * Init Mojo.
   *
   * @param toolName the name of the tool (without extension)
   * @param toolHomeDir the tool home directory
   * @param toolBinDirName the name of subdirectory where the tool live
   *                       relative to the tool home directory
   *
   * @throws MojoExecutionException if any errors occurred while processing
   *                                configuration parameters
   */
  protected void init(final String toolName, final File toolHomeDir,
      final String toolBinDirName) throws MojoExecutionException {
<span class="nc bnc" id="L657" title="All 2 branches missed.">    if (project == null) {</span>
<span class="nc" id="L658">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project} is not defined&quot;);
    }

<span class="nc bnc" id="L662" title="All 2 branches missed.">    if (session == null) {</span>
<span class="nc" id="L663">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${session} is not defined&quot;);
    }

<span class="nc" id="L667">    baseDir = project.getBasedir();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    if (baseDir == null) {</span>
<span class="nc" id="L669">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project.basedir} is not defined&quot;);
    }

<span class="nc" id="L673">    buildDir = new File(project.getBuild().getDirectory());</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">    if (buildDir == null) {</span>
<span class="nc" id="L675">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project.build.directory} is not defined&quot;);
    }

<span class="nc" id="L679">    outputDir = new File(project.getBuild().getOutputDirectory());</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">    if (outputDir == null) {</span>
<span class="nc" id="L681">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project.build.outputDirectory} is not defined&quot;);
    }

<span class="nc" id="L685">    properties = project.getProperties();</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L687">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to read project properties&quot;);
    }

<span class="nc" id="L691">    fileSetManager = new FileSetManager(getLog(), true);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">    if (fileSetManager == null) {</span>
<span class="nc" id="L693">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to create file set manager&quot;);
    }

    // Get charset to write files
<span class="nc" id="L698">    final String encoding =</span>
<span class="nc" id="L699">        properties.getProperty(&quot;project.build.sourceEncoding&quot;);</span>
    try {
<span class="nc" id="L701">      sourceEncoding = Charset.forName(encoding);</span>
<span class="nc" id="L702">    } catch (IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L704">        getLog().warn(&quot;Unable to read ${project.build.sourceEncoding}&quot;);</span>
      }
<span class="nc" id="L706">    }</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L708">      getLog().info(MessageFormat.format(</span>
          &quot;Using source encoding: [{0}] to write files&quot;, sourceEncoding));
    }

    // Resolve all available jdk toolchains
<span class="nc" id="L713">    toolchains = toolchainManager.getToolchains(session, JDK, null);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">    if (toolchains == null) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">      if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L716">        getLog().debug(&quot;No toolchains found&quot;);</span>
      }
    } else {
<span class="nc" id="L719">      toolchains.forEach(tc -&gt; {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L721">          getLog().info(&quot;Found toolchain: &quot; + tc);</span>
        }
<span class="nc" id="L723">      });</span>
    }

    // Retrieve jdk toolchain from build context,
    // i.e. the toolchain selected by maven-toolchains-plugin
<span class="nc" id="L728">    toolchain = getDefaultJavaToolchain();</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">    if (toolchain == null) {</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">      if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L731">        getLog().debug(&quot;Toolchain not specified&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L734" title="All 2 branches missed.">      if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L735">        getLog().info(&quot;Using toolchain: &quot; + toolchain);</span>
      }
    }

    // Resolve the tool home directory and executable file
<span class="nc" id="L740">    final Path executablePath =</span>
<span class="nc" id="L741">        getToolExecutable(toolName, toolHomeDir, toolBinDirName);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">    if (executablePath == null) {</span>
<span class="nc" id="L743">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Executable for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L746">    toolExecutable = executablePath.toFile();</span>

    // Obtain the tool version
    try {
<span class="nc" id="L750">      toolVersion = getToolVersion(executablePath);</span>
<span class="nc" id="L751">    } catch (CommandLineException ex) {</span>
<span class="nc" id="L752">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to obtain version of [{0}]&quot;, toolName), ex);
<span class="nc" id="L754">    }</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">    if (toolVersion == null) {</span>
<span class="nc" id="L756">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to obtain version of [{0}]&quot;, toolName));
    }
<span class="nc bnc" id="L759" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L760">      getLog().info(MessageFormat.format(&quot;Version of [{0}]: {1}&quot;, toolName,</span>
          toolVersion));
    }

    // Obtain the corresponding java version matching the tool version
    try {
<span class="nc" id="L766">      toolJavaVersion = getCorrespondingJavaVersion(toolVersion);</span>
<span class="nc" id="L767">    } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L768">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to obtain corresponding java version of [{0}]&quot;,
          toolName), ex);
<span class="nc" id="L771">    }</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L773">      getLog().info(MessageFormat.format(</span>
          &quot;Version (corresponding java version) of [{0}]: {1}&quot;, toolName,
          toolJavaVersion));
    }

<span class="nc" id="L778">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>