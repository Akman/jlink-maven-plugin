<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseToolMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JLink Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">ru.akman.maven.plugins</a> &gt; <span class="el_source">BaseToolMojo.java</span></div><h1>BaseToolMojo.java</h1><pre class="source lang-java linenums">/*
  Copyright 2020 Alexander Kapitman

  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

package ru.akman.maven.plugins;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.JavaVersion;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.BuildPluginManager;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.shared.model.fileset.util.FileSetManager;
import org.apache.maven.toolchain.Toolchain;
import org.apache.maven.toolchain.ToolchainManager;
import org.codehaus.plexus.util.cli.CommandLineException;
import org.codehaus.plexus.util.cli.CommandLineUtils;
import org.codehaus.plexus.util.cli.Commandline;

/**
 * Base class for creating a CLI tool Mojos.
 */
<span class="fc" id="L53">public abstract class BaseToolMojo extends AbstractMojo {</span>

  /**
   * The name of JDK toolchain.
   */
  private static final String JDK = &quot;jdk&quot;;

  /**
   * The name of the system environment JAVA_HOME variable.
   */
  private static final String JAVA_HOME = &quot;JAVA_HOME&quot;;

  /**
   * The value for older major versions of Java.
   */
  private static final int OLD_MAJOR = 1;

  /**
   * The value from which new major versions of Java begin.
   */
  private static final int NEW_MAJOR = 9;

  /**
   * The name of the subdirectory under JAVA_HOME where executables live.
   */
  private static final String JAVA_HOME_BIN = &quot;bin&quot;;

  /**
   * The name of the system environment PATH variable.
   */
  private static final String PATH = &quot;PATH&quot;;

  /**
   * The name of the system environment PATHEXT variable.
   */
  private static final String PATHEXT = &quot;PATHEXT&quot;;

  /**
   * The version string pattern of CLI tool.
   */
  private static final String VERSION_PATTERN = &quot;^(\\d+)\\.(\\d+).*&quot;;

  /**
   * The version option of CLI tool.
   */
  private static final String VERSION_OPTION = &quot;--version&quot;;

  /**
   * Project base directory (that containing the pom.xml file).
   */
  protected File baseDir;

  /**
   * Project build directory (${project.basedir}/target).
   */
  protected File buildDir;

  /**
   * Project output directory (${project.build.directory}/classes).
   */
  protected File outputDir;

  /**
   * Project properties.
   */
  protected Properties properties;

  /**
   * Default charset (${project.build.sourceEncoding}).
   */
<span class="fc" id="L123">  protected Charset sourceEncoding = Charset.defaultCharset();</span>

  /**
   * Fileset manager.
   */
  protected FileSetManager fileSetManager;

  /**
   * All JDK toolchains available in user settings
   * independently from maven-toolchains-plugin.
   */
  protected List&lt;Toolchain&gt; toolchains;

  /**
   * JDK toolchain from build context,
   * i.e. the toolchain selected by maven-toolchains-plugin.
   */
  protected Toolchain toolchain;

  /**
   * Tool home directory.
   */
  protected File toolHomeDir;

  /**
   * Tool executable.
   */
  protected File toolExecutable;

  /**
   * Tool version.
   */
  protected String toolVersion;

  /**
   * Tool corresponding java version.
   */
  protected JavaVersion toolJavaVersion;

  /**
   * Toolchain manager.
   */
  @Component
  protected ToolchainManager toolchainManager;

  /**
   * Build plugin manager.
   */
  @Component
  protected BuildPluginManager pluginManager;

  /**
   * Maven project.
   */
  @Parameter(
      defaultValue = &quot;${project}&quot;,
      readonly = true,
      required = true
  )
  protected MavenProject project;

  /**
   * Maven session.
   */
  @Parameter(
      defaultValue = &quot;${session}&quot;,
      readonly = true,
      required = true
  )
  protected MavenSession session;

  /**
   * Specifies the path to the JDK providing the tool needed.
   */
  @Parameter(
      readonly = true
  )
  protected File toolhome;

  /**
   * Get tool executable path from tool home.
   *
   * @param toolName the name of the tool (without extension)
   * @param toolBinDirName the name of subdirectory where the tool live
   *
   * @return tool executable path from tool home directory specified in
   *         configuration as toolhome parameter or null
   */
  private Path getExecutableFromToolHome(final String toolName,
      final String toolBinDirName) {
<span class="nc bnc" id="L213" title="All 2 branches missed.">    Path executablePath = toolhome == null</span>
<span class="nc" id="L214">        ? null</span>
<span class="nc" id="L215">        : resolveToolPath(toolName, toolhome.toPath(), toolBinDirName);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (executablePath != null) {</span>
      try {
<span class="nc" id="L218">        executablePath = executablePath.toRealPath();</span>
<span class="nc" id="L219">        toolHomeDir = toolhome;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L221">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (toolhome) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L224">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (toolhome) for [{0}]: {1}&quot;, toolName,
              toolHomeDir));
        }
<span class="nc" id="L228">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L230">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (toolhome) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L234">      }</span>
    }
<span class="nc" id="L236">    return executablePath;</span>
  }

  /**
   * Get tool executable path from default JDK toolchain.
   *
   * @param toolName the name of the tool (without extension)
   *
   * @return tool executable path from JDK toolchain specified in
   *         configuration by toolchain plugin or null
   */
  @SuppressWarnings(&quot;deprecation&quot;) // DefaultJavaToolChain
  private Path getExecutableFromToolchain(final String toolName) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">    final String tcJavaHome = toolchain == null</span>
<span class="nc" id="L250">        ? null</span>
<span class="nc" id="L251">        : org.apache.maven.toolchain.java.DefaultJavaToolChain.class.cast(</span>
<span class="nc" id="L252">            toolchain).getJavaHome();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    final String tcToolExecutable = toolchain == null</span>
<span class="nc" id="L254">        ? null</span>
<span class="nc" id="L255">        : toolchain.findTool(toolName);</span>
<span class="nc" id="L256">    Path executablePath = null;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">    if (!StringUtils.isBlank(tcJavaHome)</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        &amp;&amp; !StringUtils.isBlank(tcToolExecutable)) {</span>
      try {
<span class="nc" id="L260">        executablePath = Paths.get(tcToolExecutable).toRealPath();</span>
<span class="nc" id="L261">        toolHomeDir = new File(tcJavaHome);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L263">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (toolchain) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L266">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (toolchain) for [{0}]: {1}&quot;, toolName,
              toolHomeDir));
        }
<span class="nc" id="L270">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L272">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (toolchain) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L276">      }</span>
    }
<span class="nc" id="L278">    return executablePath;</span>
  }

  /**
   * Get tool executable path from java home.
   *
   * @param toolName the name of the tool (without extension)
   *
   * @return tool executable path from JDK home directory specified in
   *              the system environment variable JAVA_HOME or null
   */
  private Path getExecutableFromJavaHome(final String toolName) {
<span class="nc" id="L290">    final File javaHomeDir = getJavaHome();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">    Path executablePath = javaHomeDir == null</span>
<span class="nc" id="L292">        ? null</span>
<span class="nc" id="L293">        : resolveToolPath(toolName, javaHomeDir.toPath(), JAVA_HOME_BIN);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">    if (executablePath != null) {</span>
      try {
<span class="nc" id="L296">        executablePath = executablePath.toRealPath();</span>
<span class="nc" id="L297">        toolHomeDir = javaHomeDir;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L299">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (javahome) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L302">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (javahome) for [{0}]: {1}&quot;, toolName,
              toolHomeDir));
        }
<span class="nc" id="L306">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L308">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (javahome) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L312">      }</span>
    }
<span class="nc" id="L314">    return executablePath;</span>
  }

  /**
   * Get tool executable path from system path.
   *
   * @param toolName the name of the tool (without extension)
   *
   * @return tool executable path from paths specified in
   *              the system environment variable PATH or null
   */
  private Path getExecutableFromSystemPath(final String toolName) {
<span class="nc" id="L326">    final List&lt;Path&gt; systemPath = getSystemPath();</span>
<span class="nc" id="L327">    Path executablePath = null;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">    for (final Path path : systemPath) {</span>
<span class="nc" id="L329">      executablePath = resolveToolPath(toolName, path, null);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">      if (executablePath != null) {</span>
<span class="nc" id="L331">        break;</span>
      }
<span class="nc" id="L333">    }</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">    if (executablePath != null) {</span>
      try {
<span class="nc" id="L336">        final Path toolHomePath = executablePath.getParent();</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        toolHomeDir = toolHomePath == null</span>
<span class="nc" id="L338">            ? null : toolHomePath.toRealPath().toFile();</span>
<span class="nc" id="L339">        executablePath = executablePath.toRealPath();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L341">          getLog().info(MessageFormat.format(</span>
              &quot;Executable (systempath) for [{0}]: {1}&quot;, toolName,
              executablePath));
<span class="nc" id="L344">          getLog().info(MessageFormat.format(</span>
              &quot;Home directory (systempath) for [{0}]: {1}&quot;, toolName,
              toolHomeDir));
        }
<span class="nc" id="L348">      } catch (IOException ex) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L350">          getLog().error(MessageFormat.format(</span>
              &quot;Unable to resolve executable (systempath) for [{0}]: {1}&quot;,
              toolName, executablePath), ex);
        }
<span class="nc" id="L354">      }</span>
    }
<span class="nc" id="L356">    return executablePath;</span>
  }

  /**
   * Get tool executable path.
   *
   * &lt;p&gt;
   * Find tool executable in following order:
   * - toolhome (user specified tool home directory in configuration)
   * - toolchain (user specified JDK home directory by toolchains-plugin)
   * - javahome (JDK home directory specified by system variable JAVA_HOME)
   * - systempath (system path)
   * &lt;/p&gt;
   *
   * @param toolName the name of the tool (without extension)
   * @param toolBinDirName the name of subdirectory where the tool live
   *
   * @return tool executable path from tool home directory specified in
   *         configuration or by toolchain plugin or by system variable
   *         JAVA_HOME or null
   */
  private Path getToolExecutable(final String toolName,
      final String toolBinDirName) {
<span class="nc" id="L379">    Path executablePath = getExecutableFromToolHome(toolName, toolBinDirName);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L381">      return executablePath;</span>
    }
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L384">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (toolhome) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L387">    executablePath = getExecutableFromToolchain(toolName);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L389">      return executablePath;</span>
    }
<span class="nc bnc" id="L391" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L392">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (toolchain) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L395">    executablePath = getExecutableFromJavaHome(toolName);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L397">      return executablePath;</span>
    }
<span class="nc bnc" id="L399" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L400">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (javahome) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L403">    executablePath = getExecutableFromSystemPath(toolName);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">    if (executablePath != null) {</span>
<span class="nc" id="L405">      return executablePath;</span>
    }
<span class="nc bnc" id="L407" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L408">      getLog().debug(MessageFormat.format(</span>
          &quot;Executable (systempath) for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L411">    return executablePath;</span>
  }

  /**
   * Resolve the tool path against the specified home dir.
   *
   * @param toolName the name of the tool (without extension)
   * @param toolHomeDir the home path of the tool
   * @param toolBinDirName the name of subdirectory where the tool live
   *
   * @return tool executable path or null
   */
  private Path resolveToolPath(final String toolName, final Path toolHomeDir,
      final String toolBinDirName) {
<span class="nc bnc" id="L425" title="All 4 branches missed.">    if (toolHomeDir == null || StringUtils.isBlank(toolName)) {</span>
<span class="nc" id="L426">      return null;</span>
    }
<span class="nc" id="L428">    Path toolBinDir = toolHomeDir;</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">    if (!StringUtils.isBlank(toolBinDirName)) {</span>
<span class="nc" id="L430">      toolBinDir = toolHomeDir.resolve(toolBinDirName);</span>
    }
<span class="nc bnc" id="L432" title="All 4 branches missed.">    if (!Files.exists(toolBinDir) || !Files.isDirectory(toolBinDir)) {</span>
<span class="nc" id="L433">      return null;</span>
    }
<span class="nc" id="L435">    return findToolExecutable(toolName, List.of(toolBinDir));</span>
  }

  /**
   * Find tool executable under specified paths.
   *
   * @param toolName the name of the tool (without extension)
   * @param paths the list of path under which the tool will be find
   *
   * @return tool executable path or null if it not found
   */
  private Path findToolExecutable(final String toolName,
      final List&lt;Path&gt; paths) {
<span class="nc" id="L448">    Path executablePath = null;</span>
<span class="nc" id="L449">    Path toolFile = null;</span>
<span class="nc" id="L450">    final List&lt;String&gt; exts = getPathExt();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">    for (final Path path : paths) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">      if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        for (final String ext : exts) {</span>
<span class="nc" id="L454">          toolFile = path.resolve(toolName.concat(ext));</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">          if (Files.isExecutable(toolFile)</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">              &amp;&amp; !Files.isDirectory(toolFile)) {</span>
<span class="nc" id="L457">            executablePath = toolFile;</span>
<span class="nc" id="L458">            break;</span>
          }
<span class="nc" id="L460">        }</span>
      } else {
<span class="nc" id="L462">        toolFile = path.resolve(toolName);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (Files.isExecutable(toolFile)</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            &amp;&amp; !Files.isDirectory(toolFile)) {</span>
<span class="nc" id="L465">          executablePath = toolFile;</span>
<span class="nc" id="L466">          break;</span>
        }
      }
<span class="nc" id="L469">    }</span>
<span class="nc" id="L470">    return executablePath;</span>
  }

  /**
   * Get path from the system environment variable JAVA_HOME.
   *
   * @return path from the system environment variable JAVA_HOME
   */
  private File getJavaHome() {
<span class="nc" id="L479">    final String javaHome = StringUtils.stripToEmpty(System.getenv(JAVA_HOME));</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">    return StringUtils.isBlank(javaHome) ? null : new File(javaHome);</span>
  }

  /**
   * Get list of the paths registered in the system environment variable PATH.
   *
   * @return list of the paths registered in the system
   *         environment variable PATH.
   */
  private List&lt;Path&gt; getSystemPath() {
<span class="nc" id="L490">    final String systemPath = StringUtils.stripToEmpty(System.getenv(PATH));</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">    if (StringUtils.isBlank(systemPath)) {</span>
<span class="nc" id="L492">      return new ArrayList&lt;Path&gt;();</span>
    }
<span class="nc" id="L494">    return Stream.of(systemPath.split(File.pathSeparator))</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        .filter(s -&gt; !StringUtils.isBlank(s))</span>
<span class="nc" id="L496">        .map(s -&gt; Paths.get(StringUtils.stripToEmpty(s)))</span>
<span class="nc" id="L497">        .collect(Collectors.toList());</span>
  }

  /**
   * Get list of the registered path extensions from
   * the system environment variable PATHEXT.
   *
   * @return list of the registered path extensions from the system
   *         environment variable PATHEXT
   */
  private List&lt;String&gt; getPathExt() {
<span class="nc bnc" id="L508" title="All 2 branches missed.">    if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc" id="L509">      final String systemPathExt =</span>
<span class="nc" id="L510">          StringUtils.stripToEmpty(System.getenv(PATHEXT));</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">      if (!StringUtils.isBlank(systemPathExt)) {</span>
<span class="nc" id="L512">        return Stream.of(systemPathExt.split(File.pathSeparator))</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            .filter(s -&gt; !StringUtils.isBlank(s))</span>
<span class="nc" id="L514">            .map(s -&gt; StringUtils.stripToEmpty(s))</span>
<span class="nc" id="L515">            .collect(Collectors.toList());</span>
      }
    }
<span class="nc" id="L518">    return new ArrayList&lt;String&gt;();</span>
  }

  /**
   * Get the tool version.
   *
   * @return the tool version or null
   *
   * @throws CommandLineException if any errors occurred while processing
   *                              command line
   */
  private String getToolVersion(final Path executablePath)
      throws CommandLineException {
<span class="nc" id="L531">    final Commandline cmdLine = new Commandline();</span>
<span class="nc" id="L532">    cmdLine.setExecutable(executablePath.toString());</span>
<span class="nc" id="L533">    cmdLine.createArg().setValue(VERSION_OPTION);</span>
<span class="nc" id="L534">    final CommandLineUtils.StringStreamConsumer err =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L536">    final CommandLineUtils.StringStreamConsumer out =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L538">    final int exitCode =</span>
<span class="nc" id="L539">        CommandLineUtils.executeCommandLine(cmdLine, out, err);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">    return exitCode == 0</span>
<span class="nc" id="L541">        ? StringUtils.stripToEmpty(out.getOutput())</span>
<span class="nc" id="L542">            + StringUtils.stripToEmpty(err.getOutput())</span>
<span class="nc" id="L543">        : null;</span>
  }

  /**
   * Get Java version corresponding to the tool version passed in.
   *
   * @param version the tool version, not null
   *
   * @return the corresponding Java version matching the tool version
   */
  private JavaVersion getCorrespondingJavaVersion(final String version) {
<span class="nc" id="L554">    final Matcher versionMatcher = Pattern.compile(VERSION_PATTERN)</span>
<span class="nc" id="L555">        .matcher(version);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">    if (!versionMatcher.matches()) {</span>
<span class="nc" id="L557">      throw new IllegalArgumentException(&quot;Invalid version format&quot;);</span>
    }
<span class="nc" id="L559">    int majorVersion = 0;</span>
<span class="nc" id="L560">    int minorVersion = 0;</span>
    try {
<span class="nc" id="L562">      majorVersion = Integer.parseInt(versionMatcher.group(1));</span>
<span class="nc" id="L563">      minorVersion = Integer.parseInt(versionMatcher.group(2));</span>
<span class="nc" id="L564">    } catch (NumberFormatException ex) {</span>
<span class="nc" id="L565">      throw new IllegalArgumentException(&quot;Invalid version format&quot;, ex);</span>
<span class="nc" id="L566">    }</span>
<span class="nc" id="L567">    JavaVersion resolvedVersion = null;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">    if (majorVersion &gt;= NEW_MAJOR) {</span>
<span class="nc" id="L569">      resolvedVersion = JavaVersion.valueOf(&quot;JAVA_&quot; + majorVersion);</span>
    } else {
<span class="nc bnc" id="L571" title="All 2 branches missed.">      if (majorVersion == OLD_MAJOR) {</span>
<span class="nc" id="L572">        resolvedVersion = JavaVersion.valueOf(&quot;JAVA_&quot; + majorVersion</span>
            + &quot;_&quot; + minorVersion);
      } else {
<span class="nc" id="L575">        throw new IllegalArgumentException(&quot;Invalid version format&quot;);</span>
      }
    }
<span class="nc" id="L578">    return resolvedVersion;</span>
  }

  /**
   * Execute command line.
   *
   * @param cmdLine command line
   *
   * @return exit code
   *
   * @throws CommandLineException if any errors occurred while processing
   *                              command line
   */
  protected int execCmdLine(final Commandline cmdLine)
      throws CommandLineException {
<span class="nc bnc" id="L593" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L594">      getLog().debug(CommandLineUtils.toString(cmdLine.getCommandline()));</span>
    }
<span class="nc" id="L596">    final CommandLineUtils.StringStreamConsumer err =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L598">    final CommandLineUtils.StringStreamConsumer out =</span>
        new CommandLineUtils.StringStreamConsumer();
<span class="nc" id="L600">    final int exitCode = CommandLineUtils.executeCommandLine(cmdLine, out, err);</span>
<span class="nc" id="L601">    final String stdout = out.getOutput().trim();</span>
<span class="nc" id="L602">    final String stderr = err.getOutput().trim();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">    if (exitCode == 0) {</span>
<span class="nc bnc" id="L604" title="All 4 branches missed.">      if (getLog().isInfoEnabled() &amp;&amp; !StringUtils.isBlank(stdout)) {</span>
<span class="nc" id="L605">        getLog().info(System.lineSeparator()</span>
<span class="nc" id="L606">            + System.lineSeparator()</span>
            + stdout);
      }
<span class="nc bnc" id="L609" title="All 4 branches missed.">      if (getLog().isInfoEnabled() &amp;&amp; !StringUtils.isBlank(stderr)) {</span>
<span class="nc" id="L610">        getLog().info(System.lineSeparator()</span>
<span class="nc" id="L611">            + System.lineSeparator()</span>
            + stderr);
      }
    } else {
<span class="nc bnc" id="L615" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (!StringUtils.isBlank(stdout)) {</span>
<span class="nc" id="L617">          getLog().error(System.lineSeparator()</span>
              + &quot;Exit code: &quot; + exitCode
<span class="nc" id="L619">              + System.lineSeparator() + stdout);</span>
        }
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (!StringUtils.isBlank(stderr)) {</span>
<span class="nc" id="L622">          getLog().error(System.lineSeparator()</span>
              + &quot;Exit code: &quot; + exitCode
<span class="nc" id="L624">              + System.lineSeparator() + stderr);</span>
        }
<span class="nc" id="L626">        getLog().error(System.lineSeparator()</span>
            + &quot;Command line was: &quot;
<span class="nc" id="L628">            + CommandLineUtils.toString(cmdLine.getCommandline()));</span>
      }
    }
<span class="nc" id="L631">    return exitCode;</span>
  }

  /**
   * Get JDK toolchain specified in toolchains-plugin for
   * current build context.
   *
   * @return JDK toolchain
   */
  @SuppressWarnings(&quot;deprecation&quot;) // DefaultJavaToolChain
  private Toolchain getDefaultJavaToolchain() {
<span class="nc" id="L642">    final Toolchain ctxToolchain =</span>
<span class="nc" id="L643">        toolchainManager.getToolchainFromBuildContext(JDK, session);</span>
<span class="nc bnc" id="L644" title="All 4 branches missed.">    return ctxToolchain == null || !(ctxToolchain</span>
        instanceof org.apache.maven.toolchain.java.DefaultJavaToolChain)
<span class="nc" id="L646">        ? null : ctxToolchain;</span>
  }

  /**
   * Init Mojo.
   *
   * @param toolName the name of the tool (without extension)
   * @param toolBinDirName the name of subdirectory where the tool live
   *
   * @throws MojoExecutionException if any errors occurred while processing
   *                                configuration parameters
   */
  protected void init(final String toolName, final String toolBinDirName)
      throws MojoExecutionException {
<span class="nc bnc" id="L660" title="All 2 branches missed.">    if (project == null) {</span>
<span class="nc" id="L661">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project} is not defined&quot;);
    }

<span class="nc bnc" id="L665" title="All 2 branches missed.">    if (session == null) {</span>
<span class="nc" id="L666">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${session} is not defined&quot;);
    }

<span class="nc" id="L670">    baseDir = project.getBasedir();</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">    if (baseDir == null) {</span>
<span class="nc" id="L672">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project.basedir} is not defined&quot;);
    }

<span class="nc" id="L676">    buildDir = new File(project.getBuild().getDirectory());</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">    if (buildDir == null) {</span>
<span class="nc" id="L678">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project.build.directory} is not defined&quot;);
    }

<span class="nc" id="L682">    outputDir = new File(project.getBuild().getOutputDirectory());</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">    if (outputDir == null) {</span>
<span class="nc" id="L684">      throw new MojoExecutionException(</span>
          &quot;Error: The predefined variable ${project.build.outputDirectory} is not defined&quot;);
    }

<span class="nc" id="L688">    properties = project.getProperties();</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L690">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to read project properties&quot;);
    }

<span class="nc" id="L694">    fileSetManager = new FileSetManager(getLog(), true);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">    if (fileSetManager == null) {</span>
<span class="nc" id="L696">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to create file set manager&quot;);
    }

    // Get charset to write files
<span class="nc" id="L701">    final String encoding =</span>
<span class="nc" id="L702">        properties.getProperty(&quot;project.build.sourceEncoding&quot;);</span>
    try {
<span class="nc" id="L704">      sourceEncoding = Charset.forName(encoding);</span>
<span class="nc" id="L705">    } catch (IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L707">        getLog().warn(&quot;Unable to read ${project.build.sourceEncoding}&quot;);</span>
      }
<span class="nc" id="L709">    }</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L711">      getLog().info(MessageFormat.format(</span>
          &quot;Using source encoding: [{0}] to write files&quot;, sourceEncoding));
    }

    // Resolve all available jdk toolchains
<span class="nc" id="L716">    toolchains = toolchainManager.getToolchains(session, JDK, null);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">    if (toolchains == null) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">      if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L719">        getLog().debug(&quot;No toolchains found&quot;);</span>
      }
    } else {
<span class="nc" id="L722">      toolchains.forEach(tc -&gt; {</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L724">          getLog().info(&quot;Found toolchain: &quot; + tc);</span>
        }
<span class="nc" id="L726">      });</span>
    }

    // Retrieve jdk toolchain from build context,
    // i.e. the toolchain selected by maven-toolchains-plugin
<span class="nc" id="L731">    toolchain = getDefaultJavaToolchain();</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">    if (toolchain == null) {</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">      if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L734">        getLog().debug(&quot;Toolchain not specified&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L737" title="All 2 branches missed.">      if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L738">        getLog().info(&quot;Using toolchain: &quot; + toolchain);</span>
      }
    }

    // Resolve the tool home directory and executable file
<span class="nc" id="L743">    final Path executablePath = getToolExecutable(toolName, toolBinDirName);</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">    if (executablePath == null) {</span>
<span class="nc" id="L745">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Executable for [{0}] not found&quot;, toolName));
    }
<span class="nc" id="L748">    toolExecutable = executablePath.toFile();</span>

    // Obtain the tool version
    try {
<span class="nc" id="L752">      toolVersion = getToolVersion(executablePath);</span>
<span class="nc" id="L753">    } catch (CommandLineException ex) {</span>
<span class="nc" id="L754">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to obtain version of [{0}]&quot;, toolName), ex);
<span class="nc" id="L756">    }</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">    if (toolVersion == null) {</span>
<span class="nc" id="L758">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to obtain version of [{0}]&quot;, toolName));
    }
<span class="nc bnc" id="L761" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L762">      getLog().info(MessageFormat.format(&quot;Version of [{0}]: {1}&quot;, toolName,</span>
          toolVersion));
    }

    // Obtain the corresponding java version matching the tool version
    try {
<span class="nc" id="L768">      toolJavaVersion = getCorrespondingJavaVersion(toolVersion);</span>
<span class="nc" id="L769">    } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L770">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to obtain corresponding java version of [{0}]&quot;,
          toolName), ex);
<span class="nc" id="L773">    }</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L775">      getLog().info(MessageFormat.format(</span>
          &quot;Version (corresponding java version) of [{0}]: {1}&quot;, toolName,
          toolJavaVersion));
    }

<span class="nc" id="L780">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>