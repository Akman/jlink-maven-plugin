<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JlinkMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JLink Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">ru.akman.maven.plugins.jlink</a> &gt; <span class="el_source">JlinkMojo.java</span></div><h1>JlinkMojo.java</h1><pre class="source lang-java linenums">/*
  Copyright (C) 2020 Alexander Kapitman

  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

package ru.akman.maven.plugins.jlink;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.JavaVersion;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringSubstitutor;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Execute;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.shared.model.fileset.FileSet;
import org.codehaus.plexus.languages.java.jpms.JavaModuleDescriptor;
import org.codehaus.plexus.languages.java.jpms.LocationManager;
import org.codehaus.plexus.languages.java.jpms.ModuleNameSource;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsRequest;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsResult;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.cli.CommandLineException;
import org.codehaus.plexus.util.cli.Commandline;
import ru.akman.maven.plugins.BaseToolMojo;
import ru.akman.maven.plugins.CommandLineBuilder;
import ru.akman.maven.plugins.CommandLineOption;

/**
 * The jlink goal lets you create a custom runtime image with
 * the jlink tool introduced in Java 9. It used to link a set of modules,
 * along with their transitive dependences.
 *
 * &lt;p&gt;
 * The main idea is to avoid being tied to project artifacts and allow the user
 * to fully control the process of creating an image. However, it is possible,
 * of course, to customize the process using project artifacts.
 * &lt;/p&gt;
 */
@Mojo(
    name = &quot;jlink&quot;,
    defaultPhase = LifecyclePhase.PACKAGE,
    requiresDependencyResolution = ResolutionScope.RUNTIME
//    requiresProject = true
//    aggregator = &lt;false|true&gt;,
//    configurator = &quot;&lt;role hint&gt;&quot;,
//    executionStrategy = &quot;&lt;once-per-session|always&gt;&quot;,
//    inheritByDefault = &lt;true|false&gt;,
//    instantiationStrategy = InstantiationStrategy.&lt;strategy&gt;,
//    requiresDependencyCollection = ResolutionScope.&lt;scope&gt;,
//    requiresDirectInvocation = &lt;false|true&gt;,
//    requiresOnline = &lt;false|true&gt;,
//    threadSafe = &lt;false|true&gt;
)
@Execute(
    // This will fork an alternate build lifecycle up to the specified phase
    // before continuing to execute the current one.
    // If no lifecycle is specified, Maven will use the lifecycle
    // of the current build.
    phase = LifecyclePhase.PACKAGE
//
//    This will execute the given goal before execution of this one.
//    The goal name is specified using the prefix:goal notation.
//    goal = &quot;prefix:goal&quot;
//
//    This will execute the given alternate lifecycle. A custom lifecycle
//    can be defined in META-INF/maven/lifecycle.xml.
//    lifecycle = &quot;&lt;lifecycle&gt;&quot;, phase=&quot;&lt;phase&gt;&quot;
)
<span class="fc" id="L102">public class JlinkMojo extends BaseToolMojo {</span>

  /**
   * The name of the subdirectory where the tool live.
   */
  private static final String TOOL_HOME_BIN = &quot;bin&quot;;

  /**
   * The tool name.
   */
  private static final String TOOL_NAME = &quot;jlink&quot;;

  /**
   * Filename for temporary file contains the tool options.
   */
  private static final String OPTS_FILE = TOOL_NAME + &quot;.opts&quot;;

  /**
   * Filename of a module descriptor.
   */
  private static final String DESCRIPTOR_NAME = &quot;module-info.class&quot;;

  /**
   * Resolved project dependencies.
   */
  private ResolvePathsResult&lt;File&gt; projectDependencies;

  /**
   * Resolved main module descriptor.
   */
  private JavaModuleDescriptor mainModuleDescriptor;

  /**
   * JPMS location manager.
   */
  @Component
  private LocationManager locationManager;

  /**
   * Specifies the path to the JDK home directory providing the tool needed.
   */
  @Parameter
  private File toolhome;

  /**
   * Specifies the location in which modular dependencies will be copied.
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/mods&quot;
  )
  private File modsdir;

  /**
   * Specifies the location in which non modular dependencies will be copied.
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/libs&quot;
  )
  private File libsdir;

  /**
   * Specifies the module path. The path where the jlink tool discovers
   * observable modules: modular JAR files, JMOD files, exploded modules.
   * If this option is not specified, then the default module path
   * is $JAVA_HOME/jmods. This directory contains the java.base module
   * and the other standard and JDK modules. If this option is specified
   * but the java.base module cannot be resolved from it, then
   * the jlink command appends $JAVA_HOME/jmods to the module path.
   *
   * &lt;p&gt;
   * pathelements - passed to jlink as is
   * filesets - sets of files (without directories)
   * dirsets - sets of directories (without files)
   * dependencysets - sets of dependencies with specified includes and
   *                  excludes patterns (glob: or regex:) for file names
   *                  and regex patterns only for module names
   * &lt;/p&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;modulepath&amp;gt;
   *   &amp;lt;pathelements&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jar&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jmod&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mods/exploded/mod&amp;lt;/pathelement&amp;gt;
   *   &amp;lt;/pathelements&amp;gt;
   *   &amp;lt;filesets&amp;gt;
   *     &amp;lt;fileset&amp;gt;
   *       &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Empty.jar&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;false&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/fileset&amp;gt;
   *   &amp;lt;/filesets&amp;gt;
   *   &amp;lt;dirsets&amp;gt;
   *     &amp;lt;dirset&amp;gt;
   *       &amp;lt;directory&amp;gt;target&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Test&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;true&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/dirset&amp;gt;
   *   &amp;lt;/dirsets&amp;gt;
   *   &amp;lt;dependencysets&amp;gt;
   *     &amp;lt;dependencyset&amp;gt;
   *       &amp;lt;includeoutput&amp;gt;false&amp;lt;/includeoutput&amp;gt;
   *       &amp;lt;excludeautomatic&amp;gt;false&amp;lt;/excludeautomatic&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;glob:*&amp;#42;/*.jar&amp;lt;/include&amp;gt;
   *         &amp;lt;include&amp;gt;regex:foo-(bar|baz)-.*?\.jar&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;includenames&amp;gt;
   *         &amp;lt;includename&amp;gt;.*&amp;lt;/includename&amp;gt;
   *       &amp;lt;/includenames&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;glob:*&amp;#42;/javafx.*Empty&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;excludenames&amp;gt;
   *         &amp;lt;excludename&amp;gt;javafx\..+Empty&amp;lt;/excludename&amp;gt;
   *       &amp;lt;/excludenames&amp;gt;
   *     &amp;lt;/dependencyset&amp;gt;
   *   &amp;lt;/dependencysets&amp;gt;
   * &amp;lt;/modulepath&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--modulepath path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private ModulePath modulepath;

  /**
   * Specifies the modules names (names of root modules) to add to
   * the runtime image. Their transitive dependencies will add too.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;addmodules&amp;gt;
   *   &amp;lt;addmodule&amp;gt;java.base&amp;lt;/addmodule&amp;gt;
   *   &amp;lt;addmodule&amp;gt;org.example.rootmodule&amp;lt;/addmodule&amp;gt;
   * &amp;lt;/addmodules&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--add-modules module [, module...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; addmodules;

  /**
   * Specifies the location of the generated runtime image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--output path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/image&quot;
  )
  private File output;

  /**
   * Limits the universe of observable modules to those in
   * the transitive closure of the named modules, mod,
   * plus the main module, if any, plus any further
   * modules specified in the &quot;addmodules&quot; property.
   * It used to limit resolve any services other than
   * the selected services, if the property &quot;bindservices&quot;
   * set to true.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;limitmodules&amp;gt;
   *   &amp;lt;limitmodule&amp;gt;java.base&amp;lt;/limitmodule&amp;gt;
   *   &amp;lt;limitmodule&amp;gt;org.example.limitmodule&amp;lt;/limitmodule&amp;gt;
   * &amp;lt;/limitmodules&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--limit-modules module [, module...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; limitmodules;

  /**
   * Suggest providers that implement the given service types
   * from the module path.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;suggestproviders&amp;gt;
   *   &amp;lt;suggestprovider&amp;gt;provider.name&amp;lt;/suggestprovider&amp;gt;
   * &amp;lt;/suggestproviders&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--suggest-providers [name, ...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; suggestproviders;

  /**
   * Save jlink options in the given file.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--save-opts filename&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File saveopts;

  /**
   * The last plugin allowed to sort resources.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--resources-last-sorter name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String resourceslastsorter;

  /**
   * Post process an existing image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--post-process-path imagefile&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File postprocesspath;

  /**
   * Enable verbose tracing.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--verbose&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean verbose;

  /**
   * Link service provider modules and their dependencies.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--bind-services&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean bindservices;

  /**
   * Specifies the launcher command name for the module (and the main class).
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;launcher&amp;gt;
   *   &amp;lt;command&amp;gt;mylauncher&amp;lt;/command&amp;gt;
   *   &amp;lt;mainmodule&amp;gt;mainModule&amp;lt;/mainmodule&amp;gt;
   *   &amp;lt;mainclass&amp;gt;mainClass&amp;lt;/mainclass&amp;gt;
   * &amp;lt;/launcher&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--launcher command=main-module[/main-class]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Launcher launcher;

  /**
   * Excludes header files.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--no-header-files&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean noheaderfiles;

  /**
   * Excludes man pages.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--no-man-pages&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean nomanpages;

  /**
   * Specifies the byte order of the generated image: { NATIVE | LITTLE | BIG }.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--endian {little|big}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;NATIVE&quot;
  )
  private Endian endian;

  /**
   * Suppresses a fatal error when signed modular JARs are linked
   * in the runtime image. The signature-related files of the signed
   * modular JARs aren't copied to the runtime image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--ignore-signing-information&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean ignoresigninginformation;

  /**
   * Disables the specified plug-ins.
   * For a complete list of all available plug-ins,
   * run the command: &lt;code&gt;jlink --list-plugins&lt;/code&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;disableplugins&amp;gt;
   *   &amp;lt;disableplugin&amp;gt;compress&amp;lt;/disableplugin&amp;gt;
   *   &amp;lt;disableplugin&amp;gt;dedup-legal-notices&amp;lt;/disableplugin&amp;gt;
   * &amp;lt;/disableplugins&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--disable-plugin pluginname&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; disableplugins;

  /*
    For plug-in options that require a pattern-list, the value is
    a comma-separated list of elements, with each element using one
    the following forms:

      - glob-pattern
      - glob:glob-pattern
      - regex:regex-pattern
      - @filename

    Example: *&amp;#42;/module-info.class,glob:/java.base/java/lang/**,@file
  */

  /**
   * Compresses all resources in the output image. Specify
   * compression { NO_COMPRESSION | CONSTANT_STRING_SHARING | ZIP }.
   * An optional pattern-list filter can be specified to list
   * the pattern of files to include.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;compress&amp;gt;
   *   &amp;lt;compression&amp;gt;ZIP&amp;lt;/compression&amp;gt;
   *   &amp;lt;filters&amp;gt;
   *     &amp;lt;filter&amp;gt;*&amp;#42;/*-info.class&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;regex:/java[a-z]+$&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;@filename&amp;lt;/filter&amp;gt;
   *   &amp;lt;/filters&amp;gt;
   * &amp;lt;/compress&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--compress={0|1|2}[:filter=pattern-list]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Compress compress;

  /**
   * Includes the list of locales where langtag is
   * a BCP 47 language tag. This option supports locale matching as
   * defined in RFC 4647. CAUTION! Ensure that you specified:
   * &lt;code&gt;‒‒add-modules jdk.localedata&lt;/code&gt; when using this property.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;includelocales&amp;gt;
   *   &amp;lt;includelocale&amp;gt;en&amp;lt;/includelocale&amp;gt;
   *   &amp;lt;includelocale&amp;gt;ja&amp;lt;/includelocale&amp;gt;
   *   &amp;lt;includelocale&amp;gt;*-IN&amp;lt;/includelocale&amp;gt;
   * &amp;lt;/includelocales&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--include-locales=langtag[,langtag ...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; includelocales;

  /**
   * Orders the specified paths in priority order.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;orderresources&amp;gt;
   *   &amp;lt;orderresource&amp;gt;*&amp;#42;/*-info.class&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;regex:/java[a-z]+$&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;@filename&amp;lt;/orderresource&amp;gt;
   * &amp;lt;/orderresources&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--order-resources=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; orderresources;

  /**
   * Specify resources to exclude.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;excluderesources&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;*&amp;#42;/*-info.class&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;regex:/java[a-z]+$&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;@filename&amp;lt;/excluderesource&amp;gt;
   * &amp;lt;/excluderesources&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--order-resources=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; excluderesources;

  /**
   * Strips debug information from the output image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-debug&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripdebug;

  /**
   * Strip Java debug attributes from classes in the output image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-java-debug-attributes&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripjavadebugattributes;

  /**
   * Exclude native commands (such as java/java.exe) from the image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-native-commands&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripnativecommands;

  /**
   * De-duplicate all legal notices. If true is specified then
   * it will be an error if two files of the same filename
   * are different.
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--dedup-legal-notices=error-if-not-same-content&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean deduplegalnotices;

  /**
   * Specify files to exclude.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;excludefiles&amp;gt;
   *   &amp;lt;excludefile&amp;gt;*&amp;#42;/*-info.class&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;regex:/java[a-z]+$&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;@filename&amp;lt;/excludefile&amp;gt;
   * &amp;lt;/excludefiles&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--exclude-files=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; excludefiles;

  /**
   * Specify a JMOD section to exclude { MAN | HEADERS }.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--exclude-jmod-section={man|headers}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Section excludejmodsection;

  /**
   * Specify a file listing the java.lang.invoke classes to pre-generate.
   * By default, this plugin may use a builtin list of classes
   * to pre-generate. If this plugin runs on a different runtime
   * version than the image being created then code generation
   * will be disabled by default to guarantee correctness add
   * ignore-version=true to override this.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--generate-jli-classes=@filename&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File generatejliclasses;

  /**
   * Load release properties from the supplied option file.
   * - adds: is to add properties to the release file.
   * - dels: is to delete the list of keys in release file.
   * - Any number of key=value pairs can be passed.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;releaseinfo&amp;gt;
   *   &amp;lt;file&amp;gt;file&amp;lt;/file&amp;gt;
   *   &amp;lt;adds&amp;gt;
   *     &amp;lt;key1&amp;gt;value1&amp;lt;/key1&amp;gt;
   *     &amp;lt;key2&amp;gt;value2&amp;lt;/key2&amp;gt;
   *   &amp;lt;/adds&amp;gt;
   *   &amp;lt;dells&amp;gt;
   *     &amp;lt;key1 /&amp;gt;
   *     &amp;lt;key2 /&amp;gt;
   *   &amp;lt;/dells&amp;gt;
   * &amp;lt;/releaseinfo&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;/p&gt;The jlink CLI is:
   * &lt;code&gt;--release-info=file|add:key1=value1:key2=value2:...|del:key-list
   * &lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private ReleaseInfo releaseinfo;

  // /**
  //  * Fast loading of module descriptors. Always on.
  //  *
  //  * &lt;p&gt;Default value: true.&lt;/p&gt;
  //  *
  //  * &lt;p&gt;The jlink CLI is: &lt;code&gt;--system-modules=&lt;/code&gt;&lt;/p&gt;
  //  */
  // @Parameter(
  //     defaultValue = &quot;true&quot;
  // )
  // private boolean systemmodules;

  /**
   * Select the HotSpot VM in
   * the output image: { CLIENT | SERVER | MINIMAL | ALL }.
   *
   * &lt;p&gt;Default is ALL.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--vm={client|server|minimal|all}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private HotSpot vm;

  /**
   * Resolve project dependencies.
   *
   * @return map of the resolved project dependencies
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                dependencies
   */
  private ResolvePathsResult&lt;File&gt; resolveDependencies()
      throws MojoExecutionException {

    // get project artifacts - all dependencies that this project has,
    // including transitive ones (depends on what phases have run)
<span class="nc" id="L655">    final Set&lt;Artifact&gt; artifacts = getProject().getArtifacts();</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L657">      getLog().debug(PluginUtils.getArtifactSetDebugInfo(artifacts));</span>
    }

    // create a list of the paths which will be resolved
<span class="nc" id="L661">    final List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>

    // add the project output directory
<span class="nc" id="L664">    paths.add(getOutputDir());</span>

    // SCOPE_COMPILE  - This is the default scope, used if none is specified.
    //                  Compile dependencies are available in all classpaths.
    //                  Furthermore, those dependencies are propagated to
    //                  dependent projects.
    // SCOPE_PROVIDED - This is much like compile, but indicates you expect
    //                  the JDK or a container to provide it at runtime.
    //                  It is only available on the compilation and
    //                  test classpath, and is not transitive.
    // SCOPE_SYSTEM   - This scope is similar to provided except that you
    //                  have to provide the JAR which contains it explicitly.
    //                  The artifact is always available and is not looked up
    //                  in a repository.    
    // SCOPE_RUNTIME  - This scope indicates that the dependency is not
    //                  required for compilation, but is for execution.
    //                  It is in the runtime and test classpaths, but not
    //                  the compile classpath.
    // SCOPE_TEST     - This scope indicates that the dependency is not
    //                  required for normal use of the application, and is
    //                  only available for the test compilation and execution
    //                  phases. It is not transitive.
    // SCOPE_IMPORT   - This scope indicates that the dependency is a managed
    //                  POM dependency i.e. only other POM into
    //                  the dependencyManagement section.

    // [ !SCOPE_TEST ] add the project artifacts files
<span class="nc" id="L691">    paths.addAll(artifacts.stream()</span>
<span class="nc bnc" id="L692" title="All 4 branches missed.">        .filter(a -&gt; a != null &amp;&amp; !Artifact.SCOPE_TEST.equals(a.getScope()))</span>
<span class="nc" id="L693">        .map(a -&gt; a.getFile())</span>
<span class="nc" id="L694">        .collect(Collectors.toList()));</span>

    // [ SCOPE_SYSTEM ] add the project system dependencies
    // getSystemPath() is used only if the dependency scope is system
<span class="nc" id="L698">    paths.addAll(getProject().getDependencies().stream()</span>
<span class="nc bnc" id="L699" title="All 4 branches missed.">        .filter(d -&gt; d != null &amp;&amp; !StringUtils.isBlank(d.getSystemPath()))</span>
<span class="nc" id="L700">        .map(d -&gt; new File(StringUtils.stripToEmpty(d.getSystemPath())))</span>
<span class="nc" id="L701">        .collect(Collectors.toList()));</span>

    // create request contains all information
    // required to analyze the project
<span class="nc" id="L705">    final ResolvePathsRequest&lt;File&gt; request =</span>
<span class="nc" id="L706">        ResolvePathsRequest.ofFiles(paths);</span>

    // this is used to resolve main module descriptor
<span class="nc" id="L709">    final File descriptorFile =</span>
<span class="nc" id="L710">        getOutputDir().toPath().resolve(DESCRIPTOR_NAME).toFile();</span>
<span class="nc bnc" id="L711" title="All 4 branches missed.">    if (descriptorFile.exists() &amp;&amp; !descriptorFile.isDirectory()) {</span>
<span class="nc" id="L712">      request.setMainModuleDescriptor(descriptorFile);</span>
    }

    // this is used to extract the module name
<span class="nc bnc" id="L716" title="All 2 branches missed.">    if (getToolHomeDirectory() != null) {</span>
<span class="nc" id="L717">      request.setJdkHome(getToolHomeDirectory());</span>
    }

    // resolve project dependencies
    try {
<span class="nc" id="L722">      return locationManager.resolvePaths(request);</span>
<span class="nc" id="L723">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L725">        getLog().error(&quot;Unable to resolve project dependencies&quot;, ex);</span>
      }
<span class="nc" id="L727">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to resolve project dependencies&quot;, ex);
    }

  }

  /**
   * Fetch the resolved main module descriptor.
   *
   * @return main module descriptor or null if it not exists
   */
  private JavaModuleDescriptor fetchMainModuleDescriptor() {
<span class="nc" id="L739">    final JavaModuleDescriptor descriptor =</span>
<span class="nc" id="L740">        projectDependencies.getMainModuleDescriptor();</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">    if (descriptor == null) {</span>
      // detected that the project is non modular
<span class="nc bnc" id="L743" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L744">        getLog().warn(&quot;The main module descriptor not found&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L747" title="All 2 branches missed.">      if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L748">        getLog().info(MessageFormat.format(</span>
<span class="nc" id="L749">            &quot;Found the main module descriptor: [{0}]&quot;, descriptor.name()));</span>
      }
    }
<span class="nc" id="L752">    return descriptor;</span>
  }

  /**
   * Fetch path exceptions for every modulename which resolution failed.
   *
   * @return pairs of path exception file and cause
   */
  private Map&lt;File, String&gt; fetchPathExceptions() {
<span class="nc" id="L761">    return projectDependencies.getPathExceptions()</span>
<span class="nc" id="L762">        .entrySet().stream()</span>
<span class="nc bnc" id="L763" title="All 4 branches missed.">        .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L764">        .collect(Collectors.toMap(</span>
<span class="nc" id="L765">            entry -&gt; entry.getKey(),</span>
<span class="nc" id="L766">            entry -&gt; PluginUtils.getThrowableCause(entry.getValue())</span>
        ));
  }

  /**
   * Fetch classpath elements.
   *
   * @return classpath elements
   */
  private List&lt;File&gt; fetchClasspathElements() {
<span class="nc" id="L776">    final List&lt;File&gt; result = projectDependencies.getClasspathElements()</span>
<span class="nc" id="L777">        .stream()</span>
<span class="nc" id="L778">        .filter(Objects::nonNull)</span>
<span class="nc" id="L779">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L781">      getLog().info(&quot;Found classpath elements: &quot; + result.size()</span>
<span class="nc" id="L782">          + System.lineSeparator()</span>
<span class="nc" id="L783">          + result.stream()</span>
<span class="nc" id="L784">              .map(file -&gt; file.toString())</span>
<span class="nc" id="L785">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L787">    return result;</span>
  }

  /**
   * Fetch modulepath elements.
   *
   * @return modulepath elements
   */
  private List&lt;File&gt; fetchModulepathElements() {
<span class="nc" id="L796">    final List&lt;File&gt; result = projectDependencies.getModulepathElements()</span>
<span class="nc" id="L797">        .keySet()</span>
<span class="nc" id="L798">        .stream()</span>
<span class="nc" id="L799">        .filter(Objects::nonNull)</span>
<span class="nc" id="L800">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L802">      getLog().info(&quot;Found modulepath elements: &quot; + result.size()</span>
<span class="nc" id="L803">          + System.lineSeparator()</span>
<span class="nc" id="L804">          + projectDependencies.getModulepathElements().entrySet().stream()</span>
<span class="nc bnc" id="L805" title="All 4 branches missed.">              .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L806">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                  + (ModuleNameSource.FILENAME.equals(entry.getValue())</span>
<span class="nc" id="L808">                      ? System.lineSeparator()</span>
                          + &quot;[!] Detected 'requires' filename based &quot;
                          + &quot;automatic module&quot;
<span class="nc" id="L811">                          + System.lineSeparator()</span>
                          + &quot;[!] Please don't publish this project to &quot;
                          + &quot;a public artifact repository&quot;
<span class="nc" id="L814">                          + System.lineSeparator()</span>
                          + (mainModuleDescriptor != null
<span class="nc bnc" id="L816" title="All 4 branches missed.">                              &amp;&amp; mainModuleDescriptor.exports().isEmpty()</span>
<span class="nc" id="L817">                                  ? &quot;[!] APPLICATION&quot;</span>
<span class="nc" id="L818">                                  : &quot;[!] LIBRARY&quot;)</span>
<span class="nc" id="L819">                      : &quot;&quot;))</span>
<span class="nc" id="L820">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L822">    return result;</span>
  }

  /**
   * Get path from the pathelements parameter.
   *
   * @return path contains parameter elements
   */
  private String getPathElements() {
<span class="nc" id="L831">    String result = null;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L833">      final List&lt;File&gt; pathelements = modulepath.getPathElements();</span>
<span class="nc bnc" id="L834" title="All 4 branches missed.">      if (pathelements != null &amp;&amp; !pathelements.isEmpty()) {</span>
<span class="nc" id="L835">        result = pathelements.stream()</span>
<span class="nc" id="L836">            .filter(Objects::nonNull)</span>
<span class="nc" id="L837">            .map(file -&gt; file.toString())</span>
<span class="nc" id="L838">            .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">        if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L840">          getLog().debug(PluginUtils.getPathElementsDebugInfo(&quot;PATHELEMENTS&quot;,</span>
              pathelements));
<span class="nc" id="L842">          getLog().debug(result);</span>
        }
      }
    }
<span class="nc" id="L846">    return result;</span>
  }

  /**
   * Get filesets from modulepath parameter.
   *
   * @return path contains filesets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a fileset
   */
  private String getFileSets() throws MojoExecutionException {
<span class="nc" id="L858">    String result = null;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L860">      final List&lt;FileSet&gt; filesets = modulepath.getFileSets();</span>
<span class="nc bnc" id="L861" title="All 4 branches missed.">      if (filesets != null &amp;&amp; !filesets.isEmpty()) {</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">        for (final FileSet fileSet : filesets) {</span>
          final File fileSetDir;
          try {
<span class="nc" id="L865">            fileSetDir =</span>
<span class="nc" id="L866">                PluginUtils.normalizeFileSetBaseDir(getBaseDir(), fileSet);</span>
<span class="nc" id="L867">          } catch (IOException ex) {</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L869">              getLog().error(&quot;Unable to resolve fileset&quot;, ex);</span>
            }
<span class="nc" id="L871">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve fileset&quot;, ex);
<span class="nc" id="L873">          }</span>
<span class="nc" id="L874">          result = Stream.of(getFileSetManager().getIncludedFiles(fileSet))</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">              .filter(fileName -&gt; !StringUtils.isBlank(fileName))</span>
<span class="nc" id="L876">              .map(fileName -&gt; fileSetDir.toPath().resolve(</span>
<span class="nc" id="L877">                  StringUtils.stripToEmpty(fileName)).toString())</span>
<span class="nc" id="L878">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L880">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;FILESET&quot;,</span>
                fileSet, result));
          }
<span class="nc" id="L883">        }</span>
      }
    }
<span class="nc" id="L886">    return result;</span>
  }

  /**
   * Get dirsets from modulepath parameter.
   *
   * @return path contains dirsets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a dirset
   */
  private String getDirSets() throws MojoExecutionException {
<span class="nc" id="L898">    String result = null;</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L900">      final List&lt;FileSet&gt; dirsets = modulepath.getDirSets();</span>
<span class="nc bnc" id="L901" title="All 4 branches missed.">      if (dirsets != null &amp;&amp; !dirsets.isEmpty()) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">        for (final FileSet dirSet : dirsets) {</span>
          final File dirSetDir;
          try {
<span class="nc" id="L905">            dirSetDir =</span>
<span class="nc" id="L906">                PluginUtils.normalizeFileSetBaseDir(getBaseDir(), dirSet);</span>
<span class="nc" id="L907">          } catch (IOException ex) {</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L909">              getLog().error(&quot;Unable to resolve dirset&quot;, ex);</span>
            }
<span class="nc" id="L911">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve dirset&quot;, ex);
<span class="nc" id="L913">          }</span>
<span class="nc" id="L914">          result = Stream.of(getFileSetManager().getIncludedDirectories(dirSet))</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">              .filter(dirName -&gt; !StringUtils.isBlank(dirName))</span>
<span class="nc" id="L916">              .map(dirName -&gt; dirSetDir.toPath().resolve(</span>
<span class="nc" id="L917">                  StringUtils.stripToEmpty(dirName)).toString())</span>
<span class="nc" id="L918">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L920">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;DIRSET&quot;,</span>
                dirSet, result));
          }
<span class="nc" id="L923">        }</span>
      }
    }
<span class="nc" id="L926">    return result;</span>
  }

  /**
   * Get dependencysets from modulepath parameter.
   *
   * @return path contains dependencysets
   */
  private String getDependencySets() {
<span class="nc" id="L935">    String result = null;</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L937">      final List&lt;DependencySet&gt; dependencysets =</span>
<span class="nc" id="L938">          modulepath.getDependencySets();</span>
<span class="nc bnc" id="L939" title="All 4 branches missed.">      if (dependencysets != null &amp;&amp; !dependencysets.isEmpty()) {</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">        for (final DependencySet dependencySet : dependencysets) {</span>
<span class="nc" id="L941">          result = getIncludedDependencies(dependencySet)</span>
<span class="nc" id="L942">              .stream()</span>
<span class="nc" id="L943">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L945">            getLog().debug(PluginUtils.getDependencySetDebugInfo(</span>
                &quot;DEPENDENCYSET&quot;, dependencySet, result));
          }
<span class="nc" id="L948">        }</span>
      }
    }
<span class="nc" id="L951">    return result;</span>
  }

  /**
   * Get the included project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the included project dependencies
   */
  private Set&lt;String&gt; getIncludedDependencies(final DependencySet depSet) {
<span class="nc" id="L963">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">            &amp;&amp; filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L967">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L968">        .collect(Collectors.toSet());</span>
  }

  /**
   * Get the excluded project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the excluded project dependencies
   */
  private Set&lt;String&gt; getExcludedDependencies(final DependencySet depSet) {
<span class="nc" id="L980">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            &amp;&amp; !filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L984">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L985">        .collect(Collectors.toSet());</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the rules defined in the dependencyset.
   * The dependency that matches at least one include pattern will be included,
   * but if the dependency matches at least one exclude pattern too,
   * then the dependency will not be included.
   *
   * @param depSet the dependencyset
   * @param file the dependency file
   * @param descriptor the dependency module descriptor
   *
   * @return will the dependency be accepted
   */
  private boolean filterDependency(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1004" title="All 2 branches missed.">    if (descriptor == null) {</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1006">        getLog().warn(&quot;Missing module descriptor: &quot; + file);</span>
      }
    } else {
<span class="nc bnc" id="L1009" title="All 4 branches missed.">      if (descriptor.isAutomatic() &amp;&amp; getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1010">        getLog().info(&quot;Found automatic module: &quot; + file);</span>
      }
    }

<span class="nc" id="L1014">    boolean isIncluded = false;</span>

<span class="nc bnc" id="L1016" title="All 2 branches missed.">    if (depSet == null) {</span>
      // include module by default
<span class="nc" id="L1018">      isIncluded = true;</span>
      // include automatic module by default
<span class="nc bnc" id="L1020" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">          &amp;&amp; getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1022">        getLog().info(&quot;Included automatic module: &quot; + file);</span>
      }
      // exclude output module by default
<span class="nc bnc" id="L1025" title="All 2 branches missed.">      if (file.compareTo(getOutputDir()) == 0) {</span>
<span class="nc" id="L1026">        isIncluded = false;</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1028">          getLog().info(&quot;Excluded output module: &quot; + file);</span>
        }
      }
    } else {
<span class="nc bnc" id="L1032" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">          &amp;&amp; depSet.isAutomaticExcluded()) {</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1035">          getLog().info(&quot;Excluded automatic module: &quot; + file);</span>
        }
      } else {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (file.compareTo(getOutputDir()) == 0) {</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">          if (depSet.isOutputIncluded()) {</span>
<span class="nc" id="L1040">            isIncluded = true;</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1042">              getLog().info(&quot;Included output module: &quot; + file);</span>
            }
          } else {
<span class="nc bnc" id="L1045" title="All 2 branches missed.">            if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1046">              getLog().info(&quot;Excluded output module: &quot; + file);</span>
            }
          }
        } else {
<span class="nc bnc" id="L1050" title="All 2 branches missed.">          isIncluded = matchesIncludes(depSet, file, descriptor)</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">              &amp;&amp; !matchesExcludes(depSet, file, descriptor);</span>
        }
      }
    }

<span class="nc bnc" id="L1056" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1057">      getLog().debug(PluginUtils.getDependencyDebugInfo(file, descriptor,</span>
          isIncluded));
    }

<span class="nc" id="L1061">    return isIncluded;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the include patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be included
   */
  private boolean matchesIncludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1078" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1080">    final List&lt;String&gt; includes = depSet.getIncludes();</span>
<span class="nc" id="L1081">    final List&lt;String&gt; includenames = depSet.getIncludeNames();</span>

<span class="nc" id="L1083">    boolean result = true;</span>

<span class="nc bnc" id="L1085" title="All 4 branches missed.">    if (includenames == null || includenames.isEmpty()) {</span>
<span class="nc bnc" id="L1086" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1087">        result = true;</span>
      } else {
<span class="nc" id="L1089">        result = pathMatches(includes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1092" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1093">        result = nameMatches(includenames, name);</span>
      } else {
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        result = pathMatches(includes, file.toPath())</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">            || nameMatches(includenames, name);</span>
      }
    }
<span class="nc" id="L1099">    return result;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the exclude patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be excluded
   */
  private boolean matchesExcludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1116" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1118">    final List&lt;String&gt; excludes = depSet.getExcludes();</span>
<span class="nc" id="L1119">    final List&lt;String&gt; excludenames = depSet.getExcludeNames();</span>

<span class="nc" id="L1121">    boolean result = false;</span>

<span class="nc bnc" id="L1123" title="All 4 branches missed.">    if (excludenames == null || excludenames.isEmpty()) {</span>
<span class="nc bnc" id="L1124" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1125">        result = false;</span>
      } else {
<span class="nc" id="L1127">        result = pathMatches(excludes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1130" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1131">        result = nameMatches(excludenames, name);</span>
      } else {
<span class="nc bnc" id="L1133" title="All 2 branches missed.">        result = pathMatches(excludes, file.toPath())</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            || nameMatches(excludenames, name);</span>
      }
    }
<span class="nc" id="L1137">    return result;</span>
  }

  /**
   * Checks if the path matches at least one of the patterns.
   * The pattern should be regex or glob, this is determined
   * by the prefix specified in the pattern.
   *
   * @param patterns the list of patterns
   * @param path the file path
   *
   * @return true if the path matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean pathMatches(final List&lt;String&gt; patterns, final Path path) {
<span class="nc bnc" id="L1152" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
      final PathMatcher pathMatcher =
<span class="nc" id="L1154">          FileSystems.getDefault().getPathMatcher(pattern);</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">      if (pathMatcher.matches(path)) {</span>
<span class="nc" id="L1156">        return true;</span>
      }
<span class="nc" id="L1158">    }</span>
<span class="nc" id="L1159">    return false;</span>
  }

  /**
   * Checks if the name matches at least one of the patterns.
   * The pattern should be regex only.
   *
   * @param patterns the list of patterns
   * @param name the name
   *
   * @return true if the name matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean nameMatches(final List&lt;String&gt; patterns, final String name) {
<span class="nc bnc" id="L1173" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
<span class="nc" id="L1174">      final Pattern regexPattern = Pattern.compile(pattern);</span>
<span class="nc" id="L1175">      final Matcher nameMatcher = regexPattern.matcher(name);</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">      if (nameMatcher.matches()) {</span>
<span class="nc" id="L1177">        return true;</span>
      }
<span class="nc" id="L1179">    }</span>
<span class="nc" id="L1180">    return false;</span>
  }

  /**
   * Process modules.
   *
   * @param cmdLine the command line builder
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processModules(final CommandLineBuilder cmdLine)
      throws MojoExecutionException {
<span class="nc" id="L1192">    CommandLineOption opt = null;</span>
    // modulepath
<span class="nc bnc" id="L1194" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1195">      final StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1196">      final String pathElements = getPathElements();</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">      if (!StringUtils.isBlank(pathElements)) {</span>
<span class="nc" id="L1198">        path.append(StringUtils.stripToEmpty(pathElements));</span>
      }
<span class="nc" id="L1200">      final String fileSets = getFileSets();</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">      if (!StringUtils.isBlank(fileSets)) {</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1203">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1205">        path.append(StringUtils.stripToEmpty(fileSets));</span>
      }
<span class="nc" id="L1207">      final String dirSets = getDirSets();</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">      if (!StringUtils.isBlank(dirSets)) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1210">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1212">        path.append(StringUtils.stripToEmpty(dirSets));</span>
      }
<span class="nc" id="L1214">      final String dependencySets = getDependencySets();</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">      if (!StringUtils.isBlank(dependencySets)) {</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1217">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1219">        path.append(StringUtils.stripToEmpty(dependencySets));</span>
      }
<span class="nc bnc" id="L1221" title="All 2 branches missed.">      if (path.length() != 0) {</span>
<span class="nc" id="L1222">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1223">        opt.createArg().setValue(&quot;--module-path&quot;);</span>
<span class="nc" id="L1224">        opt.createArg().setValue(path.toString());</span>
      }
    }
    // addmodules
<span class="nc bnc" id="L1228" title="All 4 branches missed.">    if (includelocales != null &amp;&amp; !includelocales.isEmpty()) {</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">      if (addmodules == null) {</span>
<span class="nc" id="L1230">        addmodules = new ArrayList&lt;&gt;();</span>
      }
<span class="nc" id="L1232">      addmodules.add(&quot;jdk.localedata&quot;);</span>
    }
<span class="nc bnc" id="L1234" title="All 4 branches missed.">    if (addmodules != null &amp;&amp; !addmodules.isEmpty()) {</span>
<span class="nc" id="L1235">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1236">      opt.createArg().setValue(&quot;--add-modules&quot;);</span>
<span class="nc" id="L1237">      opt.createArg().setValue(</span>
<span class="nc" id="L1238">          addmodules.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
<span class="nc" id="L1240">  }</span>

  /**
   * Process options.
   *
   * @param cmdLine the command line builder
   */
  private void processOptions(final CommandLineBuilder cmdLine) {
<span class="nc" id="L1248">    CommandLineOption opt = null;</span>
    // output
<span class="nc" id="L1250">    opt = cmdLine.createOpt();</span>
<span class="nc" id="L1251">    opt.createArg().setValue(&quot;--output&quot;);</span>
<span class="nc" id="L1252">    opt.createArg().setFile(output);</span>
    // saveopts
<span class="nc bnc" id="L1254" title="All 2 branches missed.">    if (saveopts != null) {</span>
<span class="nc" id="L1255">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1256">      opt.createArg().setValue(&quot;--save-opts&quot;);</span>
<span class="nc" id="L1257">      opt.createArg().setFile(saveopts);</span>
    }
    // postprocesspath
<span class="nc bnc" id="L1260" title="All 2 branches missed.">    if (postprocesspath != null) {</span>
<span class="nc" id="L1261">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1262">      opt.createArg().setValue(&quot;--post-process-path&quot;);</span>
<span class="nc" id="L1263">      opt.createArg().setFile(postprocesspath);</span>
    }
    // resourceslastsorter
<span class="nc bnc" id="L1266" title="All 2 branches missed.">    if (!StringUtils.isBlank(resourceslastsorter)) {</span>
<span class="nc" id="L1267">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1268">      opt.createArg().setValue(&quot;--resources-last-sorter&quot;);</span>
<span class="nc" id="L1269">      opt.createArg().setValue(StringUtils.stripToEmpty(resourceslastsorter));</span>
    }
    // verbose
<span class="nc bnc" id="L1272" title="All 2 branches missed.">    if (verbose) {</span>
<span class="nc" id="L1273">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1274">      opt.createArg().setValue(&quot;--verbose&quot;);</span>
    }
    // bindservices
<span class="nc bnc" id="L1277" title="All 2 branches missed.">    if (bindservices) {</span>
<span class="nc" id="L1278">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1279">      opt.createArg().setValue(&quot;--bind-services&quot;);</span>
    }
    // noheaderfiles
<span class="nc bnc" id="L1282" title="All 2 branches missed.">    if (noheaderfiles) {</span>
<span class="nc" id="L1283">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1284">      opt.createArg().setValue(&quot;--no-header-files&quot;);</span>
    }
    // nomanpages
<span class="nc bnc" id="L1287" title="All 2 branches missed.">    if (nomanpages) {</span>
<span class="nc" id="L1288">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1289">      opt.createArg().setValue(&quot;--no-man-pages&quot;);</span>
    }
    // ignoresigninginformation
<span class="nc bnc" id="L1292" title="All 2 branches missed.">    if (ignoresigninginformation) {</span>
<span class="nc" id="L1293">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1294">      opt.createArg().setValue(&quot;--ignore-signing-information&quot;);</span>
    }
    // stripdebug
<span class="nc bnc" id="L1297" title="All 2 branches missed.">    if (stripdebug) {</span>
<span class="nc" id="L1298">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1299">      opt.createArg().setValue(&quot;--strip-debug&quot;);</span>
    }
    // stripjavadebugattributes
<span class="nc bnc" id="L1302" title="All 2 branches missed.">    if (stripjavadebugattributes) {</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">      if (getToolJavaVersion().atLeast(JavaVersion.JAVA_13)) {</span>
<span class="nc" id="L1304">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1305">        opt.createArg().setValue(&quot;--strip-java-debug-attributes&quot;);</span>
      } else {
<span class="nc" id="L1307">        stripjavadebugattributes = false;</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1309">          getLog().warn(MessageFormat.format(</span>
              &quot;Parameter [{0}] skiped, at least {1} is required to use it&quot;,
              &quot;--strip-java-debug-attributes&quot;,
              JavaVersion.JAVA_13));
        }
      }
    }
    // stripnativecommands
<span class="nc bnc" id="L1317" title="All 2 branches missed.">    if (stripnativecommands) {</span>
<span class="nc" id="L1318">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1319">      opt.createArg().setValue(&quot;--strip-native-commands&quot;);</span>
    }
    // deduplegalnotices
<span class="nc bnc" id="L1322" title="All 2 branches missed.">    if (deduplegalnotices) {</span>
<span class="nc" id="L1323">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1324">      opt.createArg().setValue(</span>
          &quot;--dedup-legal-notices=error-if-not-same-content&quot;);
    }
    // limitmodules
<span class="nc bnc" id="L1328" title="All 4 branches missed.">    if (limitmodules != null &amp;&amp; !limitmodules.isEmpty()) {</span>
<span class="nc" id="L1329">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1330">      opt.createArg().setValue(&quot;--limit-modules&quot;);</span>
<span class="nc" id="L1331">      opt.createArg().setValue(</span>
<span class="nc" id="L1332">          limitmodules.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
    // suggestproviders
<span class="nc bnc" id="L1335" title="All 4 branches missed.">    if (suggestproviders != null &amp;&amp; !suggestproviders.isEmpty()) {</span>
<span class="nc" id="L1336">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1337">      opt.createArg().setValue(&quot;--suggest-providers&quot;);</span>
<span class="nc" id="L1338">      opt.createArg().setValue(</span>
<span class="nc" id="L1339">          suggestproviders.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
    // endian
<span class="nc bnc" id="L1342" title="All 4 branches missed.">    if (endian != null &amp;&amp; !endian.equals(Endian.NATIVE)) {</span>
<span class="nc" id="L1343">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1344">      opt.createArg().setValue(&quot;--endian&quot;);</span>
<span class="nc" id="L1345">      opt.createArg().setValue(endian.toString().toLowerCase(Locale.ROOT));</span>
    }
    // disableplugins
<span class="nc bnc" id="L1348" title="All 2 branches missed.">    if (disableplugins != null) {</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">      for (final String plugin : disableplugins) {</span>
<span class="nc" id="L1350">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1351">        opt.createArg().setValue(&quot;--disable-plugin&quot;);</span>
<span class="nc" id="L1352">        opt.createArg().setValue(plugin);</span>
<span class="nc" id="L1353">      }</span>
    }
    // includelocales
<span class="nc bnc" id="L1356" title="All 4 branches missed.">    if (includelocales != null &amp;&amp; !includelocales.isEmpty()) {</span>
<span class="nc" id="L1357">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1358">      opt.createArg().setValue(</span>
<span class="nc" id="L1359">          includelocales.stream()</span>
<span class="nc" id="L1360">              .collect(Collectors.joining(&quot;,&quot;, &quot;--include-locales=&quot;, &quot;&quot;)));</span>
    }
    // excludejmodsection
<span class="nc bnc" id="L1363" title="All 2 branches missed.">    if (excludejmodsection != null) {</span>
<span class="nc" id="L1364">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1365">      opt.createArg().setValue(&quot;--exclude-jmod-section=&quot;</span>
<span class="nc" id="L1366">          + excludejmodsection.toString().toLowerCase(Locale.ROOT));</span>
    }
    // generatejliclasses
<span class="nc bnc" id="L1369" title="All 2 branches missed.">    if (generatejliclasses != null) {</span>
<span class="nc" id="L1370">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1371">      opt.createArg().setValue(&quot;--generate-jli-classes=@&quot;</span>
<span class="nc" id="L1372">          + generatejliclasses.toString());</span>
    }
    // vm
<span class="nc bnc" id="L1375" title="All 2 branches missed.">    if (vm != null) {</span>
<span class="nc" id="L1376">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1377">      opt.createArg().setValue(&quot;--vm=&quot;</span>
<span class="nc" id="L1378">          + vm.toString().toLowerCase(Locale.ROOT));</span>
    }
    // launcher
<span class="nc bnc" id="L1381" title="All 2 branches missed.">    if (launcher != null) {</span>
<span class="nc" id="L1382">      final String launcherCommand =</span>
<span class="nc" id="L1383">          StringUtils.stripToEmpty(launcher.getCommand());</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">      if (!StringUtils.isBlank(launcherCommand)) {</span>
<span class="nc" id="L1385">        final String launcherModule =</span>
<span class="nc" id="L1386">            StringUtils.stripToEmpty(launcher.getMainModule());</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (!StringUtils.isBlank(launcherModule)) {</span>
<span class="nc" id="L1388">          opt = cmdLine.createOpt();</span>
<span class="nc" id="L1389">          opt.createArg().setValue(&quot;--launcher&quot;);</span>
<span class="nc" id="L1390">          final String launcherClass =</span>
<span class="nc" id="L1391">              StringUtils.stripToEmpty(launcher.getMainClass());</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">          if (StringUtils.isBlank(launcherClass)) {</span>
<span class="nc" id="L1393">            opt.createArg().setValue(launcherCommand + &quot;=&quot;</span>
                + launcherModule);
          } else {
<span class="nc" id="L1396">            opt.createArg().setValue(launcherCommand + &quot;=&quot;</span>
                + launcherModule + &quot;/&quot; + launcherClass);
          }
        }
      }
    }
    // compress
<span class="nc bnc" id="L1403" title="All 2 branches missed.">    if (compress != null) {</span>
<span class="nc" id="L1404">      final Compression compression = compress.getCompression();</span>
<span class="nc" id="L1405">      final List&lt;String&gt; filters = compress.getFilters();</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">      if (compression != null) {</span>
<span class="nc" id="L1407">        final StringBuilder option = new StringBuilder(&quot;--compress=&quot;);</span>
<span class="nc" id="L1408">        option.append(compression.getValue());</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">        if (filters != null) {</span>
<span class="nc" id="L1410">          option.append(filters.stream()</span>
<span class="nc" id="L1411">              .collect(Collectors.joining(&quot;,&quot;, &quot;:filter=&quot;, &quot;&quot;)));</span>
        }
<span class="nc" id="L1413">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1414">        opt.createArg().setValue(option.toString());</span>
      }
    }
    // orderresources
<span class="nc bnc" id="L1418" title="All 4 branches missed.">    if (orderresources != null &amp;&amp; !orderresources.isEmpty()) {</span>
<span class="nc" id="L1419">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1420">      opt.createArg().setValue(orderresources.stream()</span>
<span class="nc" id="L1421">          .collect(Collectors.joining(&quot;,&quot;, &quot;--order-resources=&quot;, &quot;&quot;)));</span>
    }
    // excluderesources
<span class="nc bnc" id="L1424" title="All 4 branches missed.">    if (excluderesources != null &amp;&amp; !excluderesources.isEmpty()) {</span>
<span class="nc" id="L1425">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1426">      opt.createArg().setValue(excluderesources.stream()</span>
<span class="nc" id="L1427">          .collect(Collectors.joining(&quot;,&quot;, &quot;--exclude-resources=&quot;, &quot;&quot;)));</span>
    }
    // excludefiles
<span class="nc bnc" id="L1430" title="All 4 branches missed.">    if (excludefiles != null &amp;&amp; !excludefiles.isEmpty()) {</span>
<span class="nc" id="L1431">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1432">      opt.createArg().setValue(excludefiles.stream()</span>
<span class="nc" id="L1433">          .collect(Collectors.joining(&quot;,&quot;, &quot;--exclude-files=&quot;, &quot;&quot;)));</span>
    }
    // releaseinfo
<span class="nc bnc" id="L1436" title="All 2 branches missed.">    if (releaseinfo != null) {</span>
<span class="nc" id="L1437">      final StringBuilder option = new StringBuilder();</span>
<span class="nc" id="L1438">      final File releaseinfofile = releaseinfo.getFile();</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">      if (releaseinfofile != null) {</span>
<span class="nc" id="L1440">        option.append(releaseinfofile.toString());</span>
      }
<span class="nc" id="L1442">      final Map&lt;String, String&gt; adds = releaseinfo.getAdds();</span>
<span class="nc bnc" id="L1443" title="All 4 branches missed.">      if (adds != null &amp;&amp; !adds.entrySet().isEmpty()) {</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">        if (option.length() != 0) {</span>
<span class="nc" id="L1445">          option.append(':');</span>
        }
<span class="nc" id="L1447">        option.append(adds.entrySet().stream()</span>
<span class="nc bnc" id="L1448" title="All 4 branches missed.">            .filter(add -&gt; add != null &amp;&amp; !StringUtils.isBlank(add.getKey()))</span>
<span class="nc" id="L1449">            .map(add -&gt; StringUtils.stripToEmpty(add.getKey()) + &quot;=&quot;</span>
<span class="nc" id="L1450">                + StringUtils.stripToEmpty(add.getValue()))</span>
<span class="nc" id="L1451">            .collect(Collectors.joining(&quot;:&quot;, &quot;add:&quot;, &quot;&quot;)));</span>
      }
<span class="nc" id="L1453">      final Map&lt;String, String&gt; dels = releaseinfo.getDels();</span>
<span class="nc bnc" id="L1454" title="All 4 branches missed.">      if (dels != null &amp;&amp; !dels.entrySet().isEmpty()) {</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">        if (option.length() != 0) {</span>
<span class="nc" id="L1456">          option.append(':');</span>
        }
<span class="nc" id="L1458">        option.append(dels.entrySet().stream()</span>
<span class="nc bnc" id="L1459" title="All 4 branches missed.">            .filter(del -&gt; del != null &amp;&amp; !StringUtils.isBlank(del.getKey()))</span>
<span class="nc" id="L1460">            .map(del -&gt; StringUtils.stripToEmpty(del.getKey()))</span>
<span class="nc" id="L1461">            .collect(Collectors.joining(&quot;:&quot;, &quot;del:&quot;, &quot;&quot;)));</span>
      }
<span class="nc" id="L1463">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1464">      opt.createArg().setValue(&quot;--release-info=&quot; + option.toString());</span>
    }
<span class="nc" id="L1466">  }</span>

  /**
   * Copy files (only files, not directories) to the specified directory.
   *
   * @param files the list of files
   * @param dir the destination directory
   *
   * @throws MojoExecutionException if any errors occurred while copying a file
   */
  private void copyFiles(final List&lt;File&gt; files, final File dir)
      throws MojoExecutionException {
<span class="nc bnc" id="L1478" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1479">      getLog().debug(MessageFormat.format(&quot;Copy files to: [{0}]&quot;, dir));</span>
    }
<span class="nc bnc" id="L1481" title="All 2 branches missed.">    for (final File file : files) {</span>
      try {
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        if (file.exists()) {</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">          if (file.isDirectory()) {</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1486">              getLog().debug(MessageFormat.format(&quot;Skiped directory: [{0}]&quot;,</span>
                  file));
            }
          } else {
<span class="nc" id="L1490">            FileUtils.copyFileToDirectory(file, dir);</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1492">              getLog().debug(MessageFormat.format(&quot;Copied file: [{0}]&quot;, file));</span>
            }
          }
        }
<span class="nc" id="L1496">      } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1498">          getLog().error(MessageFormat.format(&quot;Unable to copy file: [{0}]&quot;,</span>
              file), ex);
        }
<span class="nc" id="L1501">        throw new MojoExecutionException(MessageFormat.format(</span>
            &quot;Error: Unable to copy file: [{0}]&quot;, file), ex);
<span class="nc" id="L1503">      }</span>
<span class="nc" id="L1504">    }</span>
<span class="nc" id="L1505">  }</span>

  /**
   * Process launcher scripts.
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processLauncherScripts() throws MojoExecutionException {
<span class="nc bnc" id="L1513" title="All 2 branches missed.">    if (launcher == null) {</span>
<span class="nc" id="L1514">      return;</span>
    }

<span class="nc" id="L1517">    final String scriptName = StringUtils.stripToEmpty(launcher.getCommand());</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">    if (StringUtils.isBlank(scriptName)) {</span>
<span class="nc" id="L1519">      return;</span>
    }

<span class="nc" id="L1522">    final Path nixScript = output.toPath().resolve(&quot;bin/&quot; + scriptName);</span>
<span class="nc" id="L1523">    final Path winScript = output.toPath().resolve(&quot;bin/&quot; + scriptName</span>
        + &quot;.bat&quot;);

<span class="nc bnc" id="L1526" title="All 2 branches missed.">    if (stripnativecommands) {</span>
<span class="nc bnc" id="L1527" title="All 4 branches missed.">      if (Files.exists(nixScript) &amp;&amp; !Files.isDirectory(nixScript)) {</span>
        try {
<span class="nc" id="L1529">          FileUtils.forceDelete(nixScript.toFile());</span>
<span class="nc" id="L1530">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">          if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1532">            getLog().warn(MessageFormat.format(</span>
                &quot;Unable to delete launcher script: [{0}]&quot;, nixScript));
          }
<span class="nc" id="L1535">        }</span>
      }
<span class="nc bnc" id="L1537" title="All 4 branches missed.">      if (Files.exists(winScript) &amp;&amp; !Files.isDirectory(winScript)) {</span>
        try {
<span class="nc" id="L1539">          FileUtils.forceDelete(winScript.toFile());</span>
<span class="nc" id="L1540">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">          if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1542">            getLog().warn(MessageFormat.format(</span>
                &quot;Unable to delete launcher script: [{0}]&quot;, winScript));
          }
<span class="nc" id="L1545">        }</span>
      }
<span class="nc" id="L1547">      return;</span>
    }

<span class="nc" id="L1550">    final String moduleName = StringUtils.stripToEmpty(</span>
<span class="nc" id="L1551">        launcher.getMainModule());</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">    if (StringUtils.isEmpty(moduleName)) {</span>
<span class="nc" id="L1553">      return;</span>
    }

<span class="nc" id="L1556">    final String mainClassName = StringUtils.stripToEmpty(</span>
<span class="nc" id="L1557">        launcher.getMainClass());</span>

<span class="nc" id="L1559">    final StringBuilder mainName = new StringBuilder(moduleName);</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">    if (!StringUtils.isEmpty(mainClassName)) {</span>
<span class="nc" id="L1561">      mainName</span>
<span class="nc" id="L1562">          .append('/')</span>
<span class="nc" id="L1563">          .append(mainClassName);</span>
    }

<span class="nc" id="L1566">    final String args = StringUtils.stripToEmpty(launcher.getArgs());</span>

<span class="nc" id="L1568">    final String jvmArgs = StringUtils.stripToEmpty(launcher.getJvmArgs());</span>

<span class="nc bnc" id="L1570" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1571">      getLog().debug(System.lineSeparator()</span>
          + &quot;Processing launcher scripts with following variables:&quot;
<span class="nc" id="L1573">          + System.lineSeparator()</span>
<span class="nc" id="L1574">          + MessageFormat.format(&quot;  - moduleName = [{0}]&quot;, moduleName)</span>
<span class="nc" id="L1575">          + System.lineSeparator()</span>
<span class="nc" id="L1576">          + MessageFormat.format(&quot;  - mainClassName = [{0}]&quot;, mainClassName)</span>
<span class="nc" id="L1577">          + System.lineSeparator()</span>
<span class="nc" id="L1578">          + MessageFormat.format(&quot;  - mainName = [{0}]&quot;, mainName.toString())</span>
<span class="nc" id="L1579">          + System.lineSeparator()</span>
<span class="nc" id="L1580">          + MessageFormat.format(&quot;  - args = [{0}]&quot;, args)</span>
<span class="nc" id="L1581">          + System.lineSeparator()</span>
<span class="nc" id="L1582">          + MessageFormat.format(&quot;  - jvmArgs = [{0}]&quot;, jvmArgs));</span>
    }

<span class="nc" id="L1585">    final Map&lt;String, String&gt; data = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1586">    data.put(&quot;moduleName&quot;, moduleName);</span>
<span class="nc" id="L1587">    data.put(&quot;mainClassName&quot;, mainClassName);</span>
<span class="nc" id="L1588">    data.put(&quot;mainName&quot;, mainName.toString());</span>
<span class="nc" id="L1589">    data.put(&quot;args&quot;, args);</span>
<span class="nc" id="L1590">    data.put(&quot;jvmArgs&quot;, jvmArgs);</span>

<span class="nc" id="L1592">    final File nixTemplate = launcher.getNixTemplate();</span>
<span class="nc bnc" id="L1593" title="All 4 branches missed.">    if (nixTemplate != null &amp;&amp; Files.exists(nixTemplate.toPath())</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">        &amp;&amp; !Files.isDirectory(nixTemplate.toPath())) {</span>
<span class="nc" id="L1595">      createLauncherScript(nixScript, nixTemplate.toPath(), data);</span>
    }

<span class="nc" id="L1598">    final File winTemplate = launcher.getWinTemplate();</span>
<span class="nc bnc" id="L1599" title="All 4 branches missed.">    if (winTemplate != null &amp;&amp; Files.exists(winTemplate.toPath())</span>
<span class="nc bnc" id="L1600" title="All 2 branches missed.">        &amp;&amp; !Files.isDirectory(winTemplate.toPath())) {</span>
<span class="nc" id="L1601">      createLauncherScript(winScript, winTemplate.toPath(), data);</span>
    }

<span class="nc" id="L1604">  }</span>

  /**
   * Create launcher script.
   *
   * @param script the launcher script file path
   * @param template the launcher template file path
   * @param data the hash map contains variable names and values to substitute
   *
   * @throws MojoExecutionException if any errors occurred while processing
   *                                launcher script files
   */
  private void createLauncherScript(final Path script, final Path template,
      final Map&lt;String, String&gt; data) throws MojoExecutionException {
<span class="nc bnc" id="L1618" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1619">      getLog().debug(System.lineSeparator()</span>
<span class="nc" id="L1620">          + MessageFormat.format(&quot;Fixing launcher script: [{0}]&quot;, script)</span>
<span class="nc" id="L1621">          + System.lineSeparator()</span>
<span class="nc" id="L1622">          + MessageFormat.format(&quot;with template: [{0}]&quot;, template));</span>
    }
<span class="nc" id="L1624">    final StringSubstitutor engine = new StringSubstitutor(data)</span>
<span class="nc" id="L1625">        .setEnableUndefinedVariableException(true)</span>
<span class="nc" id="L1626">        .setPreserveEscapes(true)</span>
<span class="nc" id="L1627">        .setEscapeChar('\\');</span>
    try {
<span class="nc" id="L1629">      Files.write(script,</span>
<span class="nc" id="L1630">          Files.lines(template, getCharset())</span>
<span class="nc" id="L1631">              .map(line -&gt; engine.replace(line).replace(&quot;\\$&quot;, &quot;$&quot;))</span>
<span class="nc" id="L1632">              .collect(Collectors.toList()),</span>
<span class="nc" id="L1633">          getCharset());</span>
<span class="nc" id="L1634">    } catch (IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1636">        getLog().error(MessageFormat.format(</span>
            &quot;Variable not found in the launcher template file: [{0}]&quot;,
            template), ex);
      }
<span class="nc" id="L1640">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Variable not found in the launcher template file: [{0}]&quot;, template),
          ex);
<span class="nc" id="L1643">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1645">        getLog().error(MessageFormat.format(</span>
            &quot;Unable to write to the launcher script file: [{0}]&quot;, script), ex);
      }
<span class="nc" id="L1648">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Unable to write to the launcher script file: [{0}]&quot;, script), ex);
<span class="nc" id="L1650">    }</span>
<span class="nc" id="L1651">  }</span>

  /**
   * Execute goal.
   *
   * @throws MojoExecutionException if any errors occurred
   */
  @Override
  public void execute() throws MojoExecutionException {

    // Init
<span class="nc" id="L1662">    init(TOOL_NAME, toolhome, TOOL_HOME_BIN); // from BaseToolMojo</span>

    // Check version
<span class="nc bnc" id="L1665" title="All 2 branches missed.">    if (!getToolJavaVersion().atLeast(JavaVersion.JAVA_9)) {</span>
<span class="nc" id="L1666">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: At least {0} is required to use [{1}]&quot;, JavaVersion.JAVA_9,
          TOOL_NAME));
    }

    // Create mods directory
    try {
<span class="nc" id="L1673">      FileUtils.forceMkdir(modsdir);</span>
<span class="nc" id="L1674">    } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc" id="L1675">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to create mods directory: [{0}]&quot;, modsdir), ex);
<span class="nc" id="L1677">    }</span>

    // Create libs directory
    try {
<span class="nc" id="L1681">      FileUtils.forceMkdir(libsdir);</span>
<span class="nc" id="L1682">    } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc" id="L1683">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to create libs directory: [{0}]&quot;, libsdir), ex);
<span class="nc" id="L1685">    }</span>

    // Delete image output directory if it exists
<span class="nc bnc" id="L1688" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1689">      getLog().info(MessageFormat.format(</span>
          &quot;Set image output directory to: [{0}]&quot;, output));
    }
<span class="nc bnc" id="L1692" title="All 4 branches missed.">    if (output.exists() &amp;&amp; output.isDirectory()) {</span>
      try {
<span class="nc" id="L1694">        FileUtils.deleteDirectory(output);</span>
<span class="nc" id="L1695">      } catch (IOException ex) {</span>
<span class="nc" id="L1696">        throw new MojoExecutionException(MessageFormat.format(</span>
            &quot;Error: Unable to delete image output directory: [{0}]&quot;, output),
            ex);
<span class="nc" id="L1699">      }</span>
    }

    // Resolve and fetch project dependencies
<span class="nc" id="L1703">    projectDependencies = resolveDependencies();</span>
<span class="nc" id="L1704">    mainModuleDescriptor = fetchMainModuleDescriptor();</span>
<span class="nc" id="L1705">    List&lt;File&gt; classpathElements = fetchClasspathElements();</span>
<span class="nc" id="L1706">    List&lt;File&gt; modulepathElements = fetchModulepathElements();</span>
<span class="nc" id="L1707">    Map&lt;File, String&gt; pathExceptions = fetchPathExceptions();</span>
<span class="nc bnc" id="L1708" title="All 4 branches missed.">    if (!pathExceptions.isEmpty() &amp;&amp; getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1709">      getLog().warn(&quot;Found path exceptions: &quot; + pathExceptions.size()</span>
<span class="nc" id="L1710">          + System.lineSeparator()</span>
<span class="nc" id="L1711">          + pathExceptions.entrySet().stream()</span>
<span class="nc" id="L1712">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc" id="L1713">                  + System.lineSeparator()</span>
<span class="nc" id="L1714">                  + entry.getValue())</span>
<span class="nc" id="L1715">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }

    // copy dependencies
<span class="nc" id="L1719">    copyFiles(modulepathElements, modsdir);</span>
<span class="nc" id="L1720">    copyFiles(classpathElements, libsdir);</span>

    // Build command line and populate the list of the command options
<span class="nc" id="L1723">    final CommandLineBuilder cmdLineBuilder = new CommandLineBuilder();</span>
<span class="nc" id="L1724">    cmdLineBuilder.setExecutable(getToolExecutable().toString());</span>
<span class="nc" id="L1725">    processOptions(cmdLineBuilder);</span>
<span class="nc" id="L1726">    processModules(cmdLineBuilder);</span>
<span class="nc" id="L1727">    final List&lt;String&gt; optsLines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1728">    optsLines.add(&quot;# &quot; + TOOL_NAME);</span>
<span class="nc" id="L1729">    optsLines.addAll(cmdLineBuilder.buildOptionList());</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1731">      getLog().debug(optsLines.stream()</span>
<span class="nc" id="L1732">          .collect(Collectors.joining(System.lineSeparator(),</span>
<span class="nc" id="L1733">              System.lineSeparator(), &quot;&quot;)));</span>
    }

    // Save the list of command options to the file
    // will be used in the tool command line
<span class="nc" id="L1738">    final Path cmdOptsPath = getBuildDir().toPath().resolve(OPTS_FILE);</span>
    try {
<span class="nc" id="L1740">      Files.write(cmdOptsPath, optsLines, getCharset());</span>
<span class="nc" id="L1741">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1743">        getLog().error(MessageFormat.format(</span>
            &quot;Unable to write command options to file: [{0}]&quot;, cmdOptsPath), ex);
      }
<span class="nc" id="L1746">    }</span>

    // Prepare command line with command options
    // specified in the file created early
<span class="nc" id="L1750">    final Commandline cmdLine = new Commandline();</span>
<span class="nc" id="L1751">    cmdLine.setExecutable(getToolExecutable().toString());</span>
<span class="nc" id="L1752">    cmdLine.createArg().setValue(&quot;@&quot; + cmdOptsPath.toString());</span>

    // Execute command line
<span class="nc" id="L1755">    int exitCode = 0;</span>
    try {
<span class="nc" id="L1757">      exitCode = execCmdLine(cmdLine); // from BaseToolMojo</span>
<span class="nc" id="L1758">    } catch (CommandLineException ex) {</span>
<span class="nc" id="L1759">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to execute [{0}] tool&quot;, TOOL_NAME), ex);
<span class="nc" id="L1761">    }</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">    if (exitCode != 0) {</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1764">        getLog().error(System.lineSeparator()</span>
            + &quot;Command options was: &quot;
<span class="nc" id="L1766">            + System.lineSeparator()</span>
<span class="nc" id="L1767">            + optsLines.stream()</span>
<span class="nc" id="L1768">                .collect(Collectors.joining(System.lineSeparator())));</span>
      }
<span class="nc" id="L1770">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Tool execution failed [{0}] with exit code: {1}&quot;, TOOL_NAME,
<span class="nc" id="L1772">          exitCode));</span>
    }

    // Process launcher scripts
<span class="nc" id="L1776">    processLauncherScripts();</span>

    // Delete temporary file
    try {
<span class="nc" id="L1780">      FileUtils.forceDelete(cmdOptsPath.toFile());</span>
<span class="nc" id="L1781">    } catch (IOException ex) {</span>
<span class="nc" id="L1782">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to delete temporary file: [{0}]&quot;, cmdOptsPath), ex);
<span class="nc" id="L1784">    }</span>

<span class="nc" id="L1786">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>