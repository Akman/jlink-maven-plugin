<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JlinkMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JLink Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">ru.akman.maven.plugins.jlink</a> &gt; <span class="el_source">JlinkMojo.java</span></div><h1>JlinkMojo.java</h1><pre class="source lang-java linenums">/*
  Copyright 2020 Alexander Kapitman

  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

package ru.akman.maven.plugins.jlink;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.JavaVersion;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringSubstitutor;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Execute;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.shared.model.fileset.FileSet;
import org.codehaus.plexus.languages.java.jpms.JavaModuleDescriptor;
import org.codehaus.plexus.languages.java.jpms.LocationManager;
import org.codehaus.plexus.languages.java.jpms.ModuleNameSource;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsRequest;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsResult;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.cli.CommandLineException;
import org.codehaus.plexus.util.cli.Commandline;
import ru.akman.maven.plugins.BaseToolMojo;
import ru.akman.maven.plugins.CommandLineBuilder;
import ru.akman.maven.plugins.CommandLineOption;

/**
 * The jlink goal lets you create a custom runtime image with
 * the jlink tool introduced in Java 9. It used to link a set of modules,
 * along with their transitive dependences.
 *
 * &lt;p&gt;
 * The main idea is to avoid being tied to project artifacts and allow the user
 * to fully control the process of creating an image. However, it is possible,
 * of course, to customize the process using project artifacts.
 * &lt;/p&gt;
 */
@Mojo(
    name = &quot;jlink&quot;,
    defaultPhase = LifecyclePhase.PACKAGE,
    requiresDependencyResolution = ResolutionScope.RUNTIME
//    requiresProject = true
//    aggregator = &lt;false|true&gt;,
//    configurator = &quot;&lt;role hint&gt;&quot;,
//    executionStrategy = &quot;&lt;once-per-session|always&gt;&quot;,
//    inheritByDefault = &lt;true|false&gt;,
//    instantiationStrategy = InstantiationStrategy.&lt;strategy&gt;,
//    requiresDependencyCollection = ResolutionScope.&lt;scope&gt;,
//    requiresDirectInvocation = &lt;false|true&gt;,
//    requiresOnline = &lt;false|true&gt;,
//    threadSafe = &lt;false|true&gt;
)
@Execute(
    phase = LifecyclePhase.PACKAGE
//    goal = &quot;&lt;goal-name&gt;&quot;,
//    lifecycle = &quot;&lt;lifecycle-id&gt;&quot;
)
<span class="fc" id="L92">public class JlinkMojo extends BaseToolMojo {</span>

  /**
   * The name of the subdirectory where the tool live.
   */
  private static final String TOOL_HOME_BIN = &quot;bin&quot;;

  /**
   * The tool name.
   */
  private static final String TOOL_NAME = &quot;jlink&quot;;

  /**
   * Filename for temporary file contains the tool options.
   */
  private static final String OPTS_FILE = TOOL_NAME + &quot;.opts&quot;;

  /**
   * Filename of a module descriptor.
   */
  private static final String DESCRIPTOR_NAME = &quot;module-info.class&quot;;

  /*
   * Following fields inherit from BaseToolMojo
   * ==========================================
   *
   * Maven project.
   * MavenProject project;
   *
   * Maven session.
   * MavenSession session;
   *
   * All JDK toolchains available in user settings
   * independently from maven-toolchains-plugin.
   * List&lt;Toolchain&gt; toolchains;
   *
   * JDK toolchain from build context,
   * i.e. the toolchain selected by maven-toolchains-plugin.
   * Toolchain toolchain;
   *
   * Toolchain manager.
   * ToolchainManager toolchainManager;
   *
   * Build plugin manager.
   * BuildPluginManager pluginManager;
   *
   * Fileset manager.
   * FileSetManager fileSetManager;
   *
   * Project properties.
   * Properties properties;
   *
   * Default charset (${project.build.sourceEncoding}).
   * Charset sourceEncoding = Charset.defaultCharset();
   *
   * Project base directory (that containing the pom.xml file).
   * File baseDir;
   *
   * Project build directory (${project.basedir}/target).
   * File buildDir;
   *
   * Project output directory (${project.build.directory}/classes).
   * File outputDir;
   *
   * Tool home directory.
   * File toolHomeDir;
   *
   * Tool executable.
   * File toolExecutable;
   *
   * Tool version.
   * String toolVersion;
   *
   * Tool corresponding java version.
   * JavaVersion toolJavaVersion;
   */

  /**
   * Resolved project dependencies.
   */
  private ResolvePathsResult&lt;File&gt; projectDependencies;

  /**
   * Resolved main module descriptor.
   */
  private JavaModuleDescriptor mainModuleDescriptor;

  /**
   * Path exceptions (not resolved dependencies).
   */
  private Map&lt;File, String&gt; pathExceptions;

  /**
   * Classpath elements (classpath dependencies).
   */
  private List&lt;File&gt; classpathElements;

  /**
   * Modulepath elements (modulepath dependencies).
   */
  private List&lt;File&gt; modulepathElements;

  /**
   * JPMS location manager.
   */
  @Component
  private LocationManager locationManager;

  /**
   * Specifies the location in which modular dependencies will be copied.
   *
   * &lt;p&gt;Default value: ${project.build.directory}/jlink/mods.&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/mods&quot;
  )
  private File modsdir;

  /**
   * Specifies the location in which non modular dependencies will be copied.
   *
   * &lt;p&gt;Default value: ${project.build.directory}/jlink/libs.&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/libs&quot;
  )
  private File libsdir;

  /**
   * Specifies the module path. The path where the jlink tool discovers
   * observable modules: modular JAR files, JMOD files, exploded modules.
   * If this option is not specified, then the default module path
   * is $JAVA_HOME/jmods. This directory contains the java.base module
   * and the other standard and JDK modules. If this option is specified
   * but the java.base module cannot be resolved from it, then
   * the jlink command appends $JAVA_HOME/jmods to the module path.
   *
   * &lt;p&gt;
   * pathelements - passed to jlink as is
   * filesets - sets of files (without directories)
   * dirsets - sets of directories (without files)
   * dependencysets - sets of dependencies with specified includes and
   *                  excludes patterns (glob: or regex:) for file names
   *                  and regex patterns only for module names
   * &lt;/p&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;modulepath&amp;gt;
   *   &amp;lt;pathelements&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jar&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jmod&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mods/exploded/mod&amp;lt;/pathelement&amp;gt;
   *   &amp;lt;/pathelements&amp;gt;
   *   &amp;lt;filesets&amp;gt;
   *     &amp;lt;fileset&amp;gt;
   *       &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Empty.jar&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;false&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/fileset&amp;gt;
   *   &amp;lt;/filesets&amp;gt;
   *   &amp;lt;dirsets&amp;gt;
   *     &amp;lt;dirset&amp;gt;
   *       &amp;lt;directory&amp;gt;target&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Test&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;true&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/dirset&amp;gt;
   *   &amp;lt;/dirsets&amp;gt;
   *   &amp;lt;dependencysets&amp;gt;
   *     &amp;lt;dependencyset&amp;gt;
   *       &amp;lt;includeoutput&amp;gt;false&amp;lt;/includeoutput&amp;gt;
   *       &amp;lt;excludeautomatic&amp;gt;false&amp;lt;/excludeautomatic&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;glob:*&amp;#42;/*.jar&amp;lt;/include&amp;gt;
   *         &amp;lt;include&amp;gt;regex:foo-(bar|baz)-.*?\.jar&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;includenames&amp;gt;
   *         &amp;lt;includename&amp;gt;.*&amp;lt;/includename&amp;gt;
   *       &amp;lt;/includenames&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;glob:*&amp;#42;/javafx.*Empty&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;excludenames&amp;gt;
   *         &amp;lt;excludename&amp;gt;javafx\..+Empty&amp;lt;/excludename&amp;gt;
   *       &amp;lt;/excludenames&amp;gt;
   *     &amp;lt;/dependencyset&amp;gt;
   *   &amp;lt;/dependencysets&amp;gt;
   * &amp;lt;/modulepath&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--modulepath path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private ModulePath modulepath;

  /**
   * Specifies the modules names (names of root modules) to add to
   * the runtime image. Their transitive dependencies will add too.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;addmodules&amp;gt;
   *   &amp;lt;addmodule&amp;gt;java.base&amp;lt;/addmodule&amp;gt;
   *   &amp;lt;addmodule&amp;gt;org.example.rootmodule&amp;lt;/addmodule&amp;gt;
   * &amp;lt;/addmodules&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--add-modules module [, module...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; addmodules;

  /**
   * Specifies the location of the generated runtime image.
   *
   * &lt;p&gt;Default value: ${project.build.directory}/jlink/image.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--output path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/image&quot;
  )
  private File output;

  /**
   * Limits the universe of observable modules to those in
   * the transitive closure of the named modules, mod,
   * plus the main module, if any, plus any further
   * modules specified in the &quot;addmodules&quot; property.
   * It used to limit resolve any services other than
   * the selected services, if the property &quot;bindservices&quot;
   * set to true.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;limitmodules&amp;gt;
   *   &amp;lt;limitmodule&amp;gt;java.base&amp;lt;/limitmodule&amp;gt;
   *   &amp;lt;limitmodule&amp;gt;org.example.limitmodule&amp;lt;/limitmodule&amp;gt;
   * &amp;lt;/limitmodules&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--limit-modules module [, module...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; limitmodules;

  /**
   * Suggest providers that implement the given service types
   * from the module path.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;suggestproviders&amp;gt;
   *   &amp;lt;suggestprovider&amp;gt;provider.name&amp;lt;/suggestprovider&amp;gt;
   * &amp;lt;/suggestproviders&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--suggest-providers [name, ...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; suggestproviders;

  /**
   * Save jlink options in the given file.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--save-opts filename&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File saveopts;

  /**
   * The last plugin allowed to sort resources.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--resources-last-sorter name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String resourceslastsorter;

  /**
   * Post process an existing image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--post-process-path imagefile&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File postprocesspath;

  /**
   * Enable verbose tracing.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--verbose&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean verbose;

  /**
   * Link service provider modules and their dependencies.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--bind-services&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean bindservices;

  /**
   * Specifies the launcher command name for the module (and the main class).
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;launcher&amp;gt;
   *   &amp;lt;command&amp;gt;mylauncher&amp;lt;/command&amp;gt;
   *   &amp;lt;mainmodule&amp;gt;mainModule&amp;lt;/mainmodule&amp;gt;
   *   &amp;lt;mainclass&amp;gt;mainClass&amp;lt;/mainclass&amp;gt;
   * &amp;lt;/launcher&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--launcher command=main-module[/main-class]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Launcher launcher;

  /**
   * Excludes header files.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--no-header-files&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean noheaderfiles;

  /**
   * Excludes man pages.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--no-man-pages&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean nomanpages;

  /**
   * Specifies the byte order of the generated image: { NATIVE | LITTLE | BIG }.
   *
   * &lt;p&gt;Default value: NATIVE (the format of your system's architecture).&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--endian {little|big}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;NATIVE&quot;
  )
  private Endian endian;

  /**
   * Suppresses a fatal error when signed modular JARs are linked
   * in the runtime image. The signature-related files of the signed
   * modular JARs aren't copied to the runtime image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--ignore-signing-information&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean ignoresigninginformation;

  /**
   * Disables the specified plug-ins.
   * For a complete list of all available plug-ins,
   * run the command: &lt;code&gt;jlink --list-plugins&lt;/code&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;disableplugins&amp;gt;
   *   &amp;lt;disableplugin&amp;gt;compress&amp;lt;/disableplugin&amp;gt;
   *   &amp;lt;disableplugin&amp;gt;dedup-legal-notices&amp;lt;/disableplugin&amp;gt;
   * &amp;lt;/disableplugins&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--disable-plugin pluginname&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; disableplugins;

  /*
    For plug-in options that require a pattern-list, the value is
    a comma-separated list of elements, with each element using one
    the following forms:

      - glob-pattern
      - glob:glob-pattern
      - regex:regex-pattern
      - @filename

    Example: *&amp;#42;/module-info.class,glob:/java.base/java/lang/**,@file
  */

  /**
   * Compresses all resources in the output image. Specify
   * compression { NO_COMPRESSION | CONSTANT_STRING_SHARING | ZIP }.
   * An optional pattern-list filter can be specified to list
   * the pattern of files to include.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;compress&amp;gt;
   *   &amp;lt;compression&amp;gt;ZIP&amp;lt;/compression&amp;gt;
   *   &amp;lt;filters&amp;gt;
   *     &amp;lt;filter&amp;gt;*&amp;#42;/*-info.class&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;regex:/java[a-z]+$&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;@filename&amp;lt;/filter&amp;gt;
   *   &amp;lt;/filters&amp;gt;
   * &amp;lt;/compress&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--compress={0|1|2}[:filter=pattern-list]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Compress compress;

  /**
   * Includes the list of locales where langtag is
   * a BCP 47 language tag. This option supports locale matching as
   * defined in RFC 4647. CAUTION! Ensure that you specified:
   * &lt;code&gt;‒‒add-modules jdk.localedata&lt;/code&gt; when using this property.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;includelocales&amp;gt;
   *   &amp;lt;includelocale&amp;gt;en&amp;lt;/includelocale&amp;gt;
   *   &amp;lt;includelocale&amp;gt;ja&amp;lt;/includelocale&amp;gt;
   *   &amp;lt;includelocale&amp;gt;*-IN&amp;lt;/includelocale&amp;gt;
   * &amp;lt;/includelocales&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--include-locales=langtag[,langtag ...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; includelocales;

  /**
   * Orders the specified paths in priority order.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;orderresources&amp;gt;
   *   &amp;lt;orderresource&amp;gt;*&amp;#42;/*-info.class&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;regex:/java[a-z]+$&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;@filename&amp;lt;/orderresource&amp;gt;
   * &amp;lt;/orderresources&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--order-resources=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; orderresources;

  /**
   * Specify resources to exclude.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;excluderesources&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;*&amp;#42;/*-info.class&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;regex:/java[a-z]+$&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;@filename&amp;lt;/excluderesource&amp;gt;
   * &amp;lt;/excluderesources&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--order-resources=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; excluderesources;

  /**
   * Strips debug information from the output image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-debug&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripdebug;

  /**
   * Strip Java debug attributes from classes in the output image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-java-debug-attributes&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripjavadebugattributes;

  /**
   * Exclude native commands (such as java/java.exe) from the image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-native-commands&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripnativecommands;

  /**
   * De-duplicate all legal notices. If true is specified then
   * it will be an error if two files of the same filename
   * are different.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--dedup-legal-notices=error-if-not-same-content&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean deduplegalnotices;

  /**
   * Specify files to exclude.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;excludefiles&amp;gt;
   *   &amp;lt;excludefile&amp;gt;*&amp;#42;/*-info.class&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;regex:/java[a-z]+$&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;@filename&amp;lt;/excludefile&amp;gt;
   * &amp;lt;/excludefiles&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--exclude-files=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; excludefiles;

  /**
   * Specify a JMOD section to exclude { MAN | HEADERS }.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--exclude-jmod-section={man|headers}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Section excludejmodsection;

  /**
   * Specify a file listing the java.lang.invoke classes to pre-generate.
   * By default, this plugin may use a builtin list of classes
   * to pre-generate. If this plugin runs on a different runtime
   * version than the image being created then code generation
   * will be disabled by default to guarantee correctness add
   * ignore-version=true to override this.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--generate-jli-classes=@filename&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File generatejliclasses;

  /**
   * Load release properties from the supplied option file.
   * - adds: is to add properties to the release file.
   * - dels: is to delete the list of keys in release file.
   * - Any number of key=value pairs can be passed.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;releaseinfo&amp;gt;
   *   &amp;lt;file&amp;gt;file&amp;lt;/file&amp;gt;
   *   &amp;lt;adds&amp;gt;
   *     &amp;lt;key1&amp;gt;value1&amp;lt;/key1&amp;gt;
   *     &amp;lt;key2&amp;gt;value2&amp;lt;/key2&amp;gt;
   *   &amp;lt;/adds&amp;gt;
   *   &amp;lt;dells&amp;gt;
   *     &amp;lt;key1 /&amp;gt;
   *     &amp;lt;key2 /&amp;gt;
   *   &amp;lt;/dells&amp;gt;
   * &amp;lt;/releaseinfo&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;/p&gt;The jlink CLI is:
   * &lt;code&gt;--release-info=file|add:key1=value1:key2=value2:...|del:key-list
   * &lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private ReleaseInfo releaseinfo;

  // /**
  //  * Fast loading of module descriptors. Always on.
  //  *
  //  * &lt;p&gt;Default value: true.&lt;/p&gt;
  //  *
  //  * &lt;p&gt;The jlink CLI is: &lt;code&gt;--system-modules=&lt;/code&gt;&lt;/p&gt;
  //  */
  // @Parameter(
  //     defaultValue = &quot;true&quot;
  // )
  // private boolean systemmodules;

  /**
   * Select the HotSpot VM in
   * the output image: { CLIENT | SERVER | MINIMAL | ALL }.
   *
   * &lt;p&gt;Default is ALL.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--vm={client|server|minimal|all}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private HotSpot vm;

  /**
   * Resolve project dependencies.
   *
   * @return map of the resolved project dependencies
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                dependencies
   */
  private ResolvePathsResult&lt;File&gt; resolveDependencies()
      throws MojoExecutionException {

    // get project artifacts - all dependencies that this project has,
    // including transitive ones (depends on what phases have run)
<span class="nc" id="L735">    final Set&lt;Artifact&gt; artifacts = project.getArtifacts();</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L737">      getLog().debug(PluginUtils.getArtifactSetDebugInfo(artifacts));</span>
    }

    // create a list of the paths which will be resolved
<span class="nc" id="L741">    final List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>

    // add the project output directory
<span class="nc" id="L744">    paths.add(outputDir);</span>

    // SCOPE_COMPILE  - This is the default scope, used if none is specified.
    //                  Compile dependencies are available in all classpaths.
    //                  Furthermore, those dependencies are propagated to
    //                  dependent projects.
    // SCOPE_PROVIDED - This is much like compile, but indicates you expect
    //                  the JDK or a container to provide it at runtime.
    //                  It is only available on the compilation and
    //                  test classpath, and is not transitive.
    // SCOPE_SYSTEM   - This scope is similar to provided except that you
    //                  have to provide the JAR which contains it explicitly.
    //                  The artifact is always available and is not looked up
    //                  in a repository.    
    // SCOPE_RUNTIME  - This scope indicates that the dependency is not
    //                  required for compilation, but is for execution.
    //                  It is in the runtime and test classpaths, but not
    //                  the compile classpath.
    // SCOPE_TEST     - This scope indicates that the dependency is not
    //                  required for normal use of the application, and is
    //                  only available for the test compilation and execution
    //                  phases. It is not transitive.
    // SCOPE_IMPORT   - This scope indicates that the dependency is a managed
    //                  POM dependency i.e. only other POM into
    //                  the dependencyManagement section.

    // [ !SCOPE_TEST ] add the project artifacts files
<span class="nc" id="L771">    paths.addAll(artifacts.stream()</span>
<span class="nc bnc" id="L772" title="All 4 branches missed.">        .filter(a -&gt; a != null &amp;&amp; !Artifact.SCOPE_TEST.equals(a.getScope()))</span>
<span class="nc" id="L773">        .map(a -&gt; a.getFile())</span>
<span class="nc" id="L774">        .collect(Collectors.toList()));</span>

    // [ SCOPE_SYSTEM ] add the project system dependencies
    // getSystemPath() is used only if the dependency scope is system
<span class="nc" id="L778">    paths.addAll(project.getDependencies().stream()</span>
<span class="nc bnc" id="L779" title="All 4 branches missed.">        .filter(d -&gt; d != null &amp;&amp; !StringUtils.isBlank(d.getSystemPath()))</span>
<span class="nc" id="L780">        .map(d -&gt; new File(StringUtils.stripToEmpty(d.getSystemPath())))</span>
<span class="nc" id="L781">        .collect(Collectors.toList()));</span>

    // create request contains all information
    // required to analyze the project
<span class="nc" id="L785">    final ResolvePathsRequest&lt;File&gt; request =</span>
<span class="nc" id="L786">        ResolvePathsRequest.ofFiles(paths);</span>

    // this is used to resolve main module descriptor
<span class="nc" id="L789">    final File descriptorFile =</span>
<span class="nc" id="L790">        outputDir.toPath().resolve(DESCRIPTOR_NAME).toFile();</span>
<span class="nc bnc" id="L791" title="All 4 branches missed.">    if (descriptorFile.exists() &amp;&amp; !descriptorFile.isDirectory()) {</span>
<span class="nc" id="L792">      request.setMainModuleDescriptor(descriptorFile);</span>
    }

    // this is used to extract the module name
<span class="nc bnc" id="L796" title="All 2 branches missed.">    if (toolHomeDir != null) {</span>
<span class="nc" id="L797">      request.setJdkHome(toolHomeDir);</span>
    }

    // resolve project dependencies
    try {
<span class="nc" id="L802">      return locationManager.resolvePaths(request);</span>
<span class="nc" id="L803">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L805">        getLog().error(&quot;Unable to resolve project dependencies&quot;, ex);</span>
      }
<span class="nc" id="L807">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to resolve project dependencies&quot;, ex);
    }

  }

  /**
   * Fetch the resolved main module descriptor.
   *
   * @return main module descriptor or null if it not exists
   */
  private JavaModuleDescriptor fetchMainModuleDescriptor() {
<span class="nc" id="L819">    final JavaModuleDescriptor descriptor =</span>
<span class="nc" id="L820">        projectDependencies.getMainModuleDescriptor();</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">    if (descriptor == null) {</span>
      // detected that the project is non modular
<span class="nc bnc" id="L823" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L824">        getLog().warn(&quot;The main module descriptor not found&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L827" title="All 2 branches missed.">      if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L828">        getLog().info(MessageFormat.format(</span>
<span class="nc" id="L829">            &quot;Found the main module descriptor: [{0}]&quot;, descriptor.name()));</span>
      }
    }
<span class="nc" id="L832">    return descriptor;</span>
  }

  /**
   * Fetch path exceptions for every modulename which resolution failed.
   *
   * @return pairs of path exception file and cause
   */
  private Map&lt;File, String&gt; fetchPathExceptions() {
<span class="nc" id="L841">    return projectDependencies.getPathExceptions()</span>
<span class="nc" id="L842">        .entrySet().stream()</span>
<span class="nc bnc" id="L843" title="All 4 branches missed.">        .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L844">        .collect(Collectors.toMap(</span>
<span class="nc" id="L845">            entry -&gt; entry.getKey(),</span>
<span class="nc" id="L846">            entry -&gt; PluginUtils.getThrowableCause(entry.getValue())</span>
        ));
  }

  /**
   * Fetch classpath elements.
   *
   * @return classpath elements
   */
  private List&lt;File&gt; fetchClasspathElements() {
<span class="nc" id="L856">    final List&lt;File&gt; result = projectDependencies.getClasspathElements()</span>
<span class="nc" id="L857">        .stream()</span>
<span class="nc" id="L858">        .filter(Objects::nonNull)</span>
<span class="nc" id="L859">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L861">      getLog().info(&quot;Found classpath elements: &quot; + result.size()</span>
<span class="nc" id="L862">          + System.lineSeparator()</span>
<span class="nc" id="L863">          + result.stream()</span>
<span class="nc" id="L864">              .map(file -&gt; file.toString())</span>
<span class="nc" id="L865">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L867">    return result;</span>
  }

  /**
   * Fetch modulepath elements.
   *
   * @return modulepath elements
   */
  private List&lt;File&gt; fetchModulepathElements() {
<span class="nc" id="L876">    final List&lt;File&gt; result = projectDependencies.getModulepathElements()</span>
<span class="nc" id="L877">        .keySet()</span>
<span class="nc" id="L878">        .stream()</span>
<span class="nc" id="L879">        .filter(Objects::nonNull)</span>
<span class="nc" id="L880">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L882">      getLog().info(&quot;Found modulepath elements: &quot; + result.size()</span>
<span class="nc" id="L883">          + System.lineSeparator()</span>
<span class="nc" id="L884">          + projectDependencies.getModulepathElements().entrySet().stream()</span>
<span class="nc bnc" id="L885" title="All 4 branches missed.">              .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L886">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">                  + (ModuleNameSource.FILENAME.equals(entry.getValue())</span>
<span class="nc" id="L888">                      ? System.lineSeparator()</span>
                          + &quot;[!] Detected 'requires' filename based &quot;
                          + &quot;automatic module&quot;
<span class="nc" id="L891">                          + System.lineSeparator()</span>
                          + &quot;[!] Please don't publish this project to &quot;
                          + &quot;a public artifact repository&quot;
<span class="nc" id="L894">                          + System.lineSeparator()</span>
                          + (mainModuleDescriptor != null
<span class="nc bnc" id="L896" title="All 4 branches missed.">                              &amp;&amp; mainModuleDescriptor.exports().isEmpty()</span>
<span class="nc" id="L897">                                  ? &quot;[!] APPLICATION&quot;</span>
<span class="nc" id="L898">                                  : &quot;[!] LIBRARY&quot;)</span>
<span class="nc" id="L899">                      : &quot;&quot;))</span>
<span class="nc" id="L900">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L902">    return result;</span>
  }

  /**
   * Get path from the pathelements parameter.
   *
   * @return path contains parameter elements
   */
  private String getPathElements() {
<span class="nc" id="L911">    String result = null;</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L913">      final List&lt;File&gt; pathelements = modulepath.getPathElements();</span>
<span class="nc bnc" id="L914" title="All 4 branches missed.">      if (pathelements != null &amp;&amp; !pathelements.isEmpty()) {</span>
<span class="nc" id="L915">        result = pathelements.stream()</span>
<span class="nc" id="L916">            .filter(Objects::nonNull)</span>
<span class="nc" id="L917">            .map(file -&gt; file.toString())</span>
<span class="nc" id="L918">            .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L920">          getLog().debug(PluginUtils.getPathElementsDebugInfo(&quot;PATHELEMENTS&quot;,</span>
              pathelements));
<span class="nc" id="L922">          getLog().debug(result);</span>
        }
      }
    }
<span class="nc" id="L926">    return result;</span>
  }

  /**
   * Get filesets from modulepath parameter.
   *
   * @return path contains filesets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a fileset
   */
  private String getFileSets() throws MojoExecutionException {
<span class="nc" id="L938">    String result = null;</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L940">      final List&lt;FileSet&gt; filesets = modulepath.getFileSets();</span>
<span class="nc bnc" id="L941" title="All 4 branches missed.">      if (filesets != null &amp;&amp; !filesets.isEmpty()) {</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">        for (final FileSet fileSet : filesets) {</span>
          final File fileSetDir;
          try {
<span class="nc" id="L945">            fileSetDir = PluginUtils.normalizeFileSetBaseDir(baseDir, fileSet);</span>
<span class="nc" id="L946">          } catch (IOException ex) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L948">              getLog().error(&quot;Unable to resolve fileset&quot;, ex);</span>
            }
<span class="nc" id="L950">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve fileset&quot;, ex);
<span class="nc" id="L952">          }</span>
<span class="nc" id="L953">          result = Stream.of(fileSetManager.getIncludedFiles(fileSet))</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">              .filter(fileName -&gt; !StringUtils.isBlank(fileName))</span>
<span class="nc" id="L955">              .map(fileName -&gt; fileSetDir.toPath().resolve(</span>
<span class="nc" id="L956">                  StringUtils.stripToEmpty(fileName)).toString())</span>
<span class="nc" id="L957">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L959">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;FILESET&quot;,</span>
                fileSet, result));
          }
<span class="nc" id="L962">        }</span>
      }
    }
<span class="nc" id="L965">    return result;</span>
  }

  /**
   * Get dirsets from modulepath parameter.
   *
   * @return path contains dirsets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a dirset
   */
  private String getDirSets() throws MojoExecutionException {
<span class="nc" id="L977">    String result = null;</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L979">      final List&lt;FileSet&gt; dirsets = modulepath.getDirSets();</span>
<span class="nc bnc" id="L980" title="All 4 branches missed.">      if (dirsets != null &amp;&amp; !dirsets.isEmpty()) {</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">        for (final FileSet dirSet : dirsets) {</span>
          final File dirSetDir;
          try {
<span class="nc" id="L984">            dirSetDir = PluginUtils.normalizeFileSetBaseDir(baseDir, dirSet);</span>
<span class="nc" id="L985">          } catch (IOException ex) {</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">            if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L987">              getLog().error(&quot;Unable to resolve dirset&quot;, ex);</span>
            }
<span class="nc" id="L989">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve dirset&quot;, ex);
<span class="nc" id="L991">          }</span>
<span class="nc" id="L992">          result = Stream.of(fileSetManager.getIncludedDirectories(dirSet))</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">              .filter(dirName -&gt; !StringUtils.isBlank(dirName))</span>
<span class="nc" id="L994">              .map(dirName -&gt; dirSetDir.toPath().resolve(</span>
<span class="nc" id="L995">                  StringUtils.stripToEmpty(dirName)).toString())</span>
<span class="nc" id="L996">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L998">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;DIRSET&quot;,</span>
                dirSet, result));
          }
<span class="nc" id="L1001">        }</span>
      }
    }
<span class="nc" id="L1004">    return result;</span>
  }

  /**
   * Get dependencysets from modulepath parameter.
   *
   * @return path contains dependencysets
   */
  private String getDependencySets() {
<span class="nc" id="L1013">    String result = null;</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1015">      final List&lt;DependencySet&gt; dependencysets =</span>
<span class="nc" id="L1016">          modulepath.getDependencySets();</span>
<span class="nc bnc" id="L1017" title="All 4 branches missed.">      if (dependencysets != null &amp;&amp; !dependencysets.isEmpty()) {</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">        for (final DependencySet dependencySet : dependencysets) {</span>
<span class="nc" id="L1019">          result = getIncludedDependencies(dependencySet)</span>
<span class="nc" id="L1020">              .stream()</span>
<span class="nc" id="L1021">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1023">            getLog().debug(PluginUtils.getDependencySetDebugInfo(</span>
                &quot;DEPENDENCYSET&quot;, dependencySet, result));
          }
<span class="nc" id="L1026">        }</span>
      }
    }
<span class="nc" id="L1029">    return result;</span>
  }

  /**
   * Get the included project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the included project dependencies
   */
  private Set&lt;String&gt; getIncludedDependencies(final DependencySet depSet) {
<span class="nc" id="L1041">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            &amp;&amp; filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L1045">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L1046">        .collect(Collectors.toSet());</span>
  }

  /**
   * Get the excluded project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the excluded project dependencies
   */
  private Set&lt;String&gt; getExcludedDependencies(final DependencySet depSet) {
<span class="nc" id="L1058">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">            &amp;&amp; !filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L1062">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L1063">        .collect(Collectors.toSet());</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the rules defined in the dependencyset.
   * The dependency that matches at least one include pattern will be included,
   * but if the dependency matches at least one exclude pattern too,
   * then the dependency will not be included.
   *
   * @param depSet the dependencyset
   * @param file the dependency file
   * @param descriptor the dependency module descriptor
   *
   * @return will the dependency be accepted
   */
  private boolean filterDependency(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1082" title="All 2 branches missed.">    if (descriptor == null) {</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1084">        getLog().warn(&quot;Missing module descriptor: &quot; + file);</span>
      }
    } else {
<span class="nc bnc" id="L1087" title="All 4 branches missed.">      if (descriptor.isAutomatic() &amp;&amp; getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1088">        getLog().info(&quot;Found automatic module: &quot; + file);</span>
      }
    }

<span class="nc" id="L1092">    boolean isIncluded = false;</span>

<span class="nc bnc" id="L1094" title="All 2 branches missed.">    if (depSet == null) {</span>
      // include module by default
<span class="nc" id="L1096">      isIncluded = true;</span>
      // include automatic module by default
<span class="nc bnc" id="L1098" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">          &amp;&amp; getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1100">        getLog().info(&quot;Included automatic module: &quot; + file);</span>
      }
      // exclude output module by default
<span class="nc bnc" id="L1103" title="All 2 branches missed.">      if (file.compareTo(outputDir) == 0) {</span>
<span class="nc" id="L1104">        isIncluded = false;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1106">          getLog().info(&quot;Excluded output module: &quot; + file);</span>
        }
      }
    } else {
<span class="nc bnc" id="L1110" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">          &amp;&amp; depSet.isAutomaticExcluded()) {</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1113">          getLog().info(&quot;Excluded automatic module: &quot; + file);</span>
        }
      } else {
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        if (file.compareTo(outputDir) == 0) {</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">          if (depSet.isOutputIncluded()) {</span>
<span class="nc" id="L1118">            isIncluded = true;</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1120">              getLog().info(&quot;Included output module: &quot; + file);</span>
            }
          } else {
<span class="nc bnc" id="L1123" title="All 2 branches missed.">            if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1124">              getLog().info(&quot;Excluded output module: &quot; + file);</span>
            }
          }
        } else {
<span class="nc bnc" id="L1128" title="All 2 branches missed.">          isIncluded = matchesIncludes(depSet, file, descriptor)</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">              &amp;&amp; !matchesExcludes(depSet, file, descriptor);</span>
        }
      }
    }

<span class="nc bnc" id="L1134" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1135">      getLog().debug(PluginUtils.getDependencyDebugInfo(file, descriptor,</span>
          isIncluded));
    }

<span class="nc" id="L1139">    return isIncluded;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the include patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be included
   */
  private boolean matchesIncludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1156" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1158">    final List&lt;String&gt; includes = depSet.getIncludes();</span>
<span class="nc" id="L1159">    final List&lt;String&gt; includenames = depSet.getIncludeNames();</span>

<span class="nc" id="L1161">    boolean result = true;</span>

<span class="nc bnc" id="L1163" title="All 4 branches missed.">    if (includenames == null || includenames.isEmpty()) {</span>
<span class="nc bnc" id="L1164" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1165">        result = true;</span>
      } else {
<span class="nc" id="L1167">        result = pathMatches(includes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1170" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1171">        result = nameMatches(includenames, name);</span>
      } else {
<span class="nc bnc" id="L1173" title="All 2 branches missed.">        result = pathMatches(includes, file.toPath())</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">            || nameMatches(includenames, name);</span>
      }
    }
<span class="nc" id="L1177">    return result;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the exclude patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be excluded
   */
  private boolean matchesExcludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1194" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1196">    final List&lt;String&gt; excludes = depSet.getExcludes();</span>
<span class="nc" id="L1197">    final List&lt;String&gt; excludenames = depSet.getExcludeNames();</span>

<span class="nc" id="L1199">    boolean result = false;</span>

<span class="nc bnc" id="L1201" title="All 4 branches missed.">    if (excludenames == null || excludenames.isEmpty()) {</span>
<span class="nc bnc" id="L1202" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1203">        result = false;</span>
      } else {
<span class="nc" id="L1205">        result = pathMatches(excludes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1208" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1209">        result = nameMatches(excludenames, name);</span>
      } else {
<span class="nc bnc" id="L1211" title="All 2 branches missed.">        result = pathMatches(excludes, file.toPath())</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">            || nameMatches(excludenames, name);</span>
      }
    }
<span class="nc" id="L1215">    return result;</span>
  }

  /**
   * Checks if the path matches at least one of the patterns.
   * The pattern should be regex or glob, this is determined
   * by the prefix specified in the pattern.
   *
   * @param patterns the list of patterns
   * @param path the file path
   *
   * @return true if the path matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean pathMatches(final List&lt;String&gt; patterns, final Path path) {
<span class="nc bnc" id="L1230" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
      final PathMatcher pathMatcher =
<span class="nc" id="L1232">          FileSystems.getDefault().getPathMatcher(pattern);</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">      if (pathMatcher.matches(path)) {</span>
<span class="nc" id="L1234">        return true;</span>
      }
<span class="nc" id="L1236">    }</span>
<span class="nc" id="L1237">    return false;</span>
  }

  /**
   * Checks if the name matches at least one of the patterns.
   * The pattern should be regex only.
   *
   * @param patterns the list of patterns
   * @param name the name
   *
   * @return true if the name matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean nameMatches(final List&lt;String&gt; patterns, final String name) {
<span class="nc bnc" id="L1251" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
<span class="nc" id="L1252">      final Pattern regexPattern = Pattern.compile(pattern);</span>
<span class="nc" id="L1253">      final Matcher nameMatcher = regexPattern.matcher(name);</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">      if (nameMatcher.matches()) {</span>
<span class="nc" id="L1255">        return true;</span>
      }
<span class="nc" id="L1257">    }</span>
<span class="nc" id="L1258">    return false;</span>
  }

  /**
   * Process modules.
   *
   * @param cmdLine the command line builder
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processModules(final CommandLineBuilder cmdLine)
      throws MojoExecutionException {
<span class="nc" id="L1270">    CommandLineOption opt = null;</span>
    // modulepath
<span class="nc bnc" id="L1272" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1273">      final StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1274">      final String pathElements = getPathElements();</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">      if (!StringUtils.isBlank(pathElements)) {</span>
<span class="nc" id="L1276">        path.append(StringUtils.stripToEmpty(pathElements));</span>
      }
<span class="nc" id="L1278">      final String fileSets = getFileSets();</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">      if (!StringUtils.isBlank(fileSets)) {</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1281">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1283">        path.append(StringUtils.stripToEmpty(fileSets));</span>
      }
<span class="nc" id="L1285">      final String dirSets = getDirSets();</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">      if (!StringUtils.isBlank(dirSets)) {</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1288">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1290">        path.append(StringUtils.stripToEmpty(dirSets));</span>
      }
<span class="nc" id="L1292">      final String dependencySets = getDependencySets();</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">      if (!StringUtils.isBlank(dependencySets)) {</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1295">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1297">        path.append(StringUtils.stripToEmpty(dependencySets));</span>
      }
<span class="nc bnc" id="L1299" title="All 2 branches missed.">      if (path.length() != 0) {</span>
<span class="nc" id="L1300">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1301">        opt.createArg().setValue(&quot;--module-path&quot;);</span>
<span class="nc" id="L1302">        opt.createArg().setValue(path.toString());</span>
      }
    }
    // addmodules
<span class="nc bnc" id="L1306" title="All 4 branches missed.">    if (includelocales != null &amp;&amp; !includelocales.isEmpty()) {</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">      if (addmodules == null) {</span>
<span class="nc" id="L1308">        addmodules = new ArrayList&lt;&gt;();</span>
      }
<span class="nc" id="L1310">      addmodules.add(&quot;jdk.localedata&quot;);</span>
    }
<span class="nc bnc" id="L1312" title="All 4 branches missed.">    if (addmodules != null &amp;&amp; !addmodules.isEmpty()) {</span>
<span class="nc" id="L1313">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1314">      opt.createArg().setValue(&quot;--add-modules&quot;);</span>
<span class="nc" id="L1315">      opt.createArg().setValue(</span>
<span class="nc" id="L1316">          addmodules.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
<span class="nc" id="L1318">  }</span>

  /**
   * Process options.
   *
   * @param cmdLine the command line builder
   */
  private void processOptions(final CommandLineBuilder cmdLine) {
<span class="nc" id="L1326">    CommandLineOption opt = null;</span>
    // output
<span class="nc" id="L1328">    opt = cmdLine.createOpt();</span>
<span class="nc" id="L1329">    opt.createArg().setValue(&quot;--output&quot;);</span>
<span class="nc" id="L1330">    opt.createArg().setFile(output);</span>
    // saveopts
<span class="nc bnc" id="L1332" title="All 2 branches missed.">    if (saveopts != null) {</span>
<span class="nc" id="L1333">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1334">      opt.createArg().setValue(&quot;--save-opts&quot;);</span>
<span class="nc" id="L1335">      opt.createArg().setFile(saveopts);</span>
    }
    // postprocesspath
<span class="nc bnc" id="L1338" title="All 2 branches missed.">    if (postprocesspath != null) {</span>
<span class="nc" id="L1339">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1340">      opt.createArg().setValue(&quot;--post-process-path&quot;);</span>
<span class="nc" id="L1341">      opt.createArg().setFile(postprocesspath);</span>
    }
    // resourceslastsorter
<span class="nc bnc" id="L1344" title="All 2 branches missed.">    if (!StringUtils.isBlank(resourceslastsorter)) {</span>
<span class="nc" id="L1345">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1346">      opt.createArg().setValue(&quot;--resources-last-sorter&quot;);</span>
<span class="nc" id="L1347">      opt.createArg().setValue(StringUtils.stripToEmpty(resourceslastsorter));</span>
    }
    // verbose
<span class="nc bnc" id="L1350" title="All 2 branches missed.">    if (verbose) {</span>
<span class="nc" id="L1351">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1352">      opt.createArg().setValue(&quot;--verbose&quot;);</span>
    }
    // bindservices
<span class="nc bnc" id="L1355" title="All 2 branches missed.">    if (bindservices) {</span>
<span class="nc" id="L1356">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1357">      opt.createArg().setValue(&quot;--bind-services&quot;);</span>
    }
    // noheaderfiles
<span class="nc bnc" id="L1360" title="All 2 branches missed.">    if (noheaderfiles) {</span>
<span class="nc" id="L1361">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1362">      opt.createArg().setValue(&quot;--no-header-files&quot;);</span>
    }
    // nomanpages
<span class="nc bnc" id="L1365" title="All 2 branches missed.">    if (nomanpages) {</span>
<span class="nc" id="L1366">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1367">      opt.createArg().setValue(&quot;--no-man-pages&quot;);</span>
    }
    // ignoresigninginformation
<span class="nc bnc" id="L1370" title="All 2 branches missed.">    if (ignoresigninginformation) {</span>
<span class="nc" id="L1371">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1372">      opt.createArg().setValue(&quot;--ignore-signing-information&quot;);</span>
    }
    // stripdebug
<span class="nc bnc" id="L1375" title="All 2 branches missed.">    if (stripdebug) {</span>
<span class="nc" id="L1376">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1377">      opt.createArg().setValue(&quot;--strip-debug&quot;);</span>
    }
    // stripjavadebugattributes
<span class="nc bnc" id="L1380" title="All 2 branches missed.">    if (stripjavadebugattributes) {</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">      if (toolJavaVersion.atLeast(JavaVersion.JAVA_13)) {</span>
<span class="nc" id="L1382">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1383">        opt.createArg().setValue(&quot;--strip-java-debug-attributes&quot;);</span>
      } else {
<span class="nc" id="L1385">        stripjavadebugattributes = false;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">        if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1387">          getLog().warn(MessageFormat.format(</span>
              &quot;Parameter [{0}] skiped, at least {1} is required to use it&quot;,
              &quot;--strip-java-debug-attributes&quot;,
              JavaVersion.JAVA_13));
        }
      }
    }
    // stripnativecommands
<span class="nc bnc" id="L1395" title="All 2 branches missed.">    if (stripnativecommands) {</span>
<span class="nc" id="L1396">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1397">      opt.createArg().setValue(&quot;--strip-native-commands&quot;);</span>
    }
    // deduplegalnotices
<span class="nc bnc" id="L1400" title="All 2 branches missed.">    if (deduplegalnotices) {</span>
<span class="nc" id="L1401">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1402">      opt.createArg().setValue(</span>
          &quot;--dedup-legal-notices=error-if-not-same-content&quot;);
    }
    // limitmodules
<span class="nc bnc" id="L1406" title="All 4 branches missed.">    if (limitmodules != null &amp;&amp; !limitmodules.isEmpty()) {</span>
<span class="nc" id="L1407">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1408">      opt.createArg().setValue(&quot;--limit-modules&quot;);</span>
<span class="nc" id="L1409">      opt.createArg().setValue(</span>
<span class="nc" id="L1410">          limitmodules.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
    // suggestproviders
<span class="nc bnc" id="L1413" title="All 4 branches missed.">    if (suggestproviders != null &amp;&amp; !suggestproviders.isEmpty()) {</span>
<span class="nc" id="L1414">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1415">      opt.createArg().setValue(&quot;--suggest-providers&quot;);</span>
<span class="nc" id="L1416">      opt.createArg().setValue(</span>
<span class="nc" id="L1417">          suggestproviders.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
    // endian
<span class="nc bnc" id="L1420" title="All 4 branches missed.">    if (endian != null &amp;&amp; !endian.equals(Endian.NATIVE)) {</span>
<span class="nc" id="L1421">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1422">      opt.createArg().setValue(&quot;--endian&quot;);</span>
<span class="nc" id="L1423">      opt.createArg().setValue(endian.toString().toLowerCase(Locale.ROOT));</span>
    }
    // disableplugins
<span class="nc bnc" id="L1426" title="All 2 branches missed.">    if (disableplugins != null) {</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">      for (final String plugin : disableplugins) {</span>
<span class="nc" id="L1428">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1429">        opt.createArg().setValue(&quot;--disable-plugin&quot;);</span>
<span class="nc" id="L1430">        opt.createArg().setValue(plugin);</span>
<span class="nc" id="L1431">      }</span>
    }
    // includelocales
<span class="nc bnc" id="L1434" title="All 4 branches missed.">    if (includelocales != null &amp;&amp; !includelocales.isEmpty()) {</span>
<span class="nc" id="L1435">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1436">      opt.createArg().setValue(</span>
<span class="nc" id="L1437">          includelocales.stream()</span>
<span class="nc" id="L1438">              .collect(Collectors.joining(&quot;,&quot;, &quot;--include-locales=&quot;, &quot;&quot;)));</span>
    }
    // excludejmodsection
<span class="nc bnc" id="L1441" title="All 2 branches missed.">    if (excludejmodsection != null) {</span>
<span class="nc" id="L1442">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1443">      opt.createArg().setValue(&quot;--exclude-jmod-section=&quot;</span>
<span class="nc" id="L1444">          + excludejmodsection.toString().toLowerCase(Locale.ROOT));</span>
    }
    // generatejliclasses
<span class="nc bnc" id="L1447" title="All 2 branches missed.">    if (generatejliclasses != null) {</span>
<span class="nc" id="L1448">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1449">      opt.createArg().setValue(&quot;--generate-jli-classes=@&quot;</span>
<span class="nc" id="L1450">          + generatejliclasses.toString());</span>
    }
    // vm
<span class="nc bnc" id="L1453" title="All 2 branches missed.">    if (vm != null) {</span>
<span class="nc" id="L1454">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1455">      opt.createArg().setValue(&quot;--vm=&quot;</span>
<span class="nc" id="L1456">          + vm.toString().toLowerCase(Locale.ROOT));</span>
    }
    // launcher
<span class="nc bnc" id="L1459" title="All 2 branches missed.">    if (launcher != null) {</span>
<span class="nc" id="L1460">      final String launcherCommand =</span>
<span class="nc" id="L1461">          StringUtils.stripToEmpty(launcher.getCommand());</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">      if (!StringUtils.isBlank(launcherCommand)) {</span>
<span class="nc" id="L1463">        final String launcherModule =</span>
<span class="nc" id="L1464">            StringUtils.stripToEmpty(launcher.getMainModule());</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">        if (!StringUtils.isBlank(launcherModule)) {</span>
<span class="nc" id="L1466">          opt = cmdLine.createOpt();</span>
<span class="nc" id="L1467">          opt.createArg().setValue(&quot;--launcher&quot;);</span>
<span class="nc" id="L1468">          final String launcherClass =</span>
<span class="nc" id="L1469">              StringUtils.stripToEmpty(launcher.getMainClass());</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">          if (StringUtils.isBlank(launcherClass)) {</span>
<span class="nc" id="L1471">            opt.createArg().setValue(launcherCommand + &quot;=&quot;</span>
                + launcherModule);
          } else {
<span class="nc" id="L1474">            opt.createArg().setValue(launcherCommand + &quot;=&quot;</span>
                + launcherModule + &quot;/&quot; + launcherClass);
          }
        }
      }
    }
    // compress
<span class="nc bnc" id="L1481" title="All 2 branches missed.">    if (compress != null) {</span>
<span class="nc" id="L1482">      final Compression compression = compress.getCompression();</span>
<span class="nc" id="L1483">      final List&lt;String&gt; filters = compress.getFilters();</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">      if (compression != null) {</span>
<span class="nc" id="L1485">        final StringBuilder option = new StringBuilder(&quot;--compress=&quot;);</span>
<span class="nc" id="L1486">        option.append(compression.getValue());</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">        if (filters != null) {</span>
<span class="nc" id="L1488">          option.append(filters.stream()</span>
<span class="nc" id="L1489">              .collect(Collectors.joining(&quot;,&quot;, &quot;:filter=&quot;, &quot;&quot;)));</span>
        }
<span class="nc" id="L1491">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1492">        opt.createArg().setValue(option.toString());</span>
      }
    }
    // orderresources
<span class="nc bnc" id="L1496" title="All 4 branches missed.">    if (orderresources != null &amp;&amp; !orderresources.isEmpty()) {</span>
<span class="nc" id="L1497">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1498">      opt.createArg().setValue(orderresources.stream()</span>
<span class="nc" id="L1499">          .collect(Collectors.joining(&quot;,&quot;, &quot;--order-resources=&quot;, &quot;&quot;)));</span>
    }
    // excluderesources
<span class="nc bnc" id="L1502" title="All 4 branches missed.">    if (excluderesources != null &amp;&amp; !excluderesources.isEmpty()) {</span>
<span class="nc" id="L1503">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1504">      opt.createArg().setValue(excluderesources.stream()</span>
<span class="nc" id="L1505">          .collect(Collectors.joining(&quot;,&quot;, &quot;--exclude-resources=&quot;, &quot;&quot;)));</span>
    }
    // excludefiles
<span class="nc bnc" id="L1508" title="All 4 branches missed.">    if (excludefiles != null &amp;&amp; !excludefiles.isEmpty()) {</span>
<span class="nc" id="L1509">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1510">      opt.createArg().setValue(excludefiles.stream()</span>
<span class="nc" id="L1511">          .collect(Collectors.joining(&quot;,&quot;, &quot;--exclude-files=&quot;, &quot;&quot;)));</span>
    }
    // releaseinfo
<span class="nc bnc" id="L1514" title="All 2 branches missed.">    if (releaseinfo != null) {</span>
<span class="nc" id="L1515">      final StringBuilder option = new StringBuilder();</span>
<span class="nc" id="L1516">      final File releaseinfofile = releaseinfo.getFile();</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">      if (releaseinfofile != null) {</span>
<span class="nc" id="L1518">        option.append(releaseinfofile.toString());</span>
      }
<span class="nc" id="L1520">      final Map&lt;String, String&gt; adds = releaseinfo.getAdds();</span>
<span class="nc bnc" id="L1521" title="All 4 branches missed.">      if (adds != null &amp;&amp; !adds.entrySet().isEmpty()) {</span>
<span class="nc bnc" id="L1522" title="All 2 branches missed.">        if (option.length() != 0) {</span>
<span class="nc" id="L1523">          option.append(':');</span>
        }
<span class="nc" id="L1525">        option.append(adds.entrySet().stream()</span>
<span class="nc bnc" id="L1526" title="All 4 branches missed.">            .filter(add -&gt; add != null &amp;&amp; !StringUtils.isBlank(add.getKey()))</span>
<span class="nc" id="L1527">            .map(add -&gt; StringUtils.stripToEmpty(add.getKey()) + &quot;=&quot;</span>
<span class="nc" id="L1528">                + StringUtils.stripToEmpty(add.getValue()))</span>
<span class="nc" id="L1529">            .collect(Collectors.joining(&quot;:&quot;, &quot;add:&quot;, &quot;&quot;)));</span>
      }
<span class="nc" id="L1531">      final Map&lt;String, String&gt; dels = releaseinfo.getDels();</span>
<span class="nc bnc" id="L1532" title="All 4 branches missed.">      if (dels != null &amp;&amp; !dels.entrySet().isEmpty()) {</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">        if (option.length() != 0) {</span>
<span class="nc" id="L1534">          option.append(':');</span>
        }
<span class="nc" id="L1536">        option.append(dels.entrySet().stream()</span>
<span class="nc bnc" id="L1537" title="All 4 branches missed.">            .filter(del -&gt; del != null &amp;&amp; !StringUtils.isBlank(del.getKey()))</span>
<span class="nc" id="L1538">            .map(del -&gt; StringUtils.stripToEmpty(del.getKey()))</span>
<span class="nc" id="L1539">            .collect(Collectors.joining(&quot;:&quot;, &quot;del:&quot;, &quot;&quot;)));</span>
      }
<span class="nc" id="L1541">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1542">      opt.createArg().setValue(&quot;--release-info=&quot; + option.toString());</span>
    }
<span class="nc" id="L1544">  }</span>

  /**
   * Copy files (only files, not directories) to the specified directory.
   *
   * @param files the list of files
   * @param dir the destination directory
   *
   * @throws MojoExecutionException if any errors occurred while copying a file
   */
  private void copyFiles(final List&lt;File&gt; files, final File dir)
      throws MojoExecutionException {
<span class="nc bnc" id="L1556" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1557">      getLog().debug(MessageFormat.format(&quot;Copy files to: [{0}]&quot;, dir));</span>
    }
<span class="nc bnc" id="L1559" title="All 2 branches missed.">    for (final File file : files) {</span>
      try {
<span class="nc bnc" id="L1561" title="All 2 branches missed.">        if (file.exists()) {</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">          if (file.isDirectory()) {</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1564">              getLog().debug(MessageFormat.format(&quot;Skiped directory: [{0}]&quot;,</span>
                  file));
            }
          } else {
<span class="nc" id="L1568">            FileUtils.copyFileToDirectory(file, dir);</span>
<span class="nc bnc" id="L1569" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1570">              getLog().debug(MessageFormat.format(&quot;Copied file: [{0}]&quot;, file));</span>
            }
          }
        }
<span class="nc" id="L1574">      } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1576">          getLog().error(MessageFormat.format(&quot;Unable to copy file: [{0}]&quot;,</span>
              file), ex);
        }
<span class="nc" id="L1579">        throw new MojoExecutionException(MessageFormat.format(</span>
            &quot;Error: Unable to copy file: [{0}]&quot;, file), ex);
<span class="nc" id="L1581">      }</span>
<span class="nc" id="L1582">    }</span>
<span class="nc" id="L1583">  }</span>

  /**
   * Process launcher scripts.
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processLauncherScripts() throws MojoExecutionException {
<span class="nc bnc" id="L1591" title="All 2 branches missed.">    if (launcher == null) {</span>
<span class="nc" id="L1592">      return;</span>
    }

<span class="nc" id="L1595">    final String scriptName = StringUtils.stripToEmpty(launcher.getCommand());</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">    if (StringUtils.isBlank(scriptName)) {</span>
<span class="nc" id="L1597">      return;</span>
    }

<span class="nc" id="L1600">    final Path nixScript = output.toPath().resolve(&quot;bin/&quot; + scriptName);</span>
<span class="nc" id="L1601">    final Path winScript = output.toPath().resolve(&quot;bin/&quot; + scriptName</span>
        + &quot;.bat&quot;);

<span class="nc bnc" id="L1604" title="All 2 branches missed.">    if (stripnativecommands) {</span>
<span class="nc bnc" id="L1605" title="All 4 branches missed.">      if (Files.exists(nixScript) &amp;&amp; !Files.isDirectory(nixScript)) {</span>
        try {
<span class="nc" id="L1607">          FileUtils.forceDelete(nixScript.toFile());</span>
<span class="nc" id="L1608">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">          if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1610">            getLog().warn(MessageFormat.format(</span>
                &quot;Unable to delete launcher script: [{0}]&quot;, nixScript));
          }
<span class="nc" id="L1613">        }</span>
      }
<span class="nc bnc" id="L1615" title="All 4 branches missed.">      if (Files.exists(winScript) &amp;&amp; !Files.isDirectory(winScript)) {</span>
        try {
<span class="nc" id="L1617">          FileUtils.forceDelete(winScript.toFile());</span>
<span class="nc" id="L1618">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">          if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1620">            getLog().warn(MessageFormat.format(</span>
                &quot;Unable to delete launcher script: [{0}]&quot;, winScript));
          }
<span class="nc" id="L1623">        }</span>
      }
<span class="nc" id="L1625">      return;</span>
    }

<span class="nc" id="L1628">    final String moduleName = StringUtils.stripToEmpty(</span>
<span class="nc" id="L1629">        launcher.getMainModule());</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">    if (StringUtils.isEmpty(moduleName)) {</span>
<span class="nc" id="L1631">      return;</span>
    }

<span class="nc" id="L1634">    final String mainClassName = StringUtils.stripToEmpty(</span>
<span class="nc" id="L1635">        launcher.getMainClass());</span>

<span class="nc" id="L1637">    final StringBuilder mainName = new StringBuilder(moduleName);</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">    if (!StringUtils.isEmpty(mainClassName)) {</span>
<span class="nc" id="L1639">      mainName</span>
<span class="nc" id="L1640">          .append('/')</span>
<span class="nc" id="L1641">          .append(mainClassName);</span>
    }

<span class="nc" id="L1644">    final String args = StringUtils.stripToEmpty(launcher.getArgs());</span>

<span class="nc" id="L1646">    final String jvmArgs = StringUtils.stripToEmpty(launcher.getJvmArgs());</span>

<span class="nc bnc" id="L1648" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1649">      getLog().debug(System.lineSeparator()</span>
          + &quot;Processing launcher scripts with following variables:&quot;
<span class="nc" id="L1651">          + System.lineSeparator()</span>
<span class="nc" id="L1652">          + MessageFormat.format(&quot;  - moduleName = [{0}]&quot;, moduleName)</span>
<span class="nc" id="L1653">          + System.lineSeparator()</span>
<span class="nc" id="L1654">          + MessageFormat.format(&quot;  - mainClassName = [{0}]&quot;, mainClassName)</span>
<span class="nc" id="L1655">          + System.lineSeparator()</span>
<span class="nc" id="L1656">          + MessageFormat.format(&quot;  - mainName = [{0}]&quot;, mainName.toString())</span>
<span class="nc" id="L1657">          + System.lineSeparator()</span>
<span class="nc" id="L1658">          + MessageFormat.format(&quot;  - args = [{0}]&quot;, args)</span>
<span class="nc" id="L1659">          + System.lineSeparator()</span>
<span class="nc" id="L1660">          + MessageFormat.format(&quot;  - jvmArgs = [{0}]&quot;, jvmArgs));</span>
    }

<span class="nc" id="L1663">    final Map&lt;String, String&gt; data = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1664">    data.put(&quot;moduleName&quot;, moduleName);</span>
<span class="nc" id="L1665">    data.put(&quot;mainClassName&quot;, mainClassName);</span>
<span class="nc" id="L1666">    data.put(&quot;mainName&quot;, mainName.toString());</span>
<span class="nc" id="L1667">    data.put(&quot;args&quot;, args);</span>
<span class="nc" id="L1668">    data.put(&quot;jvmArgs&quot;, jvmArgs);</span>

<span class="nc" id="L1670">    final File nixTemplate = launcher.getNixTemplate();</span>
<span class="nc bnc" id="L1671" title="All 4 branches missed.">    if (nixTemplate != null &amp;&amp; Files.exists(nixTemplate.toPath())</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">        &amp;&amp; !Files.isDirectory(nixTemplate.toPath())) {</span>
<span class="nc" id="L1673">      createLauncherScript(nixScript, nixTemplate.toPath(), data);</span>
    }

<span class="nc" id="L1676">    final File winTemplate = launcher.getWinTemplate();</span>
<span class="nc bnc" id="L1677" title="All 4 branches missed.">    if (winTemplate != null &amp;&amp; Files.exists(winTemplate.toPath())</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">        &amp;&amp; !Files.isDirectory(winTemplate.toPath())) {</span>
<span class="nc" id="L1679">      createLauncherScript(winScript, winTemplate.toPath(), data);</span>
    }

<span class="nc" id="L1682">  }</span>

  /**
   * Create launcher script.
   *
   * @param script the launcher script file path
   * @param template the launcher template file path
   * @param data the hash map contains variable names and values to substitute
   *
   * @throws MojoExecutionException if any errors occurred while processing
   *                                launcher script files
   */
  private void createLauncherScript(final Path script, final Path template,
      final Map&lt;String, String&gt; data) throws MojoExecutionException {
<span class="nc bnc" id="L1696" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1697">      getLog().debug(System.lineSeparator()</span>
<span class="nc" id="L1698">          + MessageFormat.format(&quot;Fixing launcher script: [{0}]&quot;, script)</span>
<span class="nc" id="L1699">          + System.lineSeparator()</span>
<span class="nc" id="L1700">          + MessageFormat.format(&quot;with template: [{0}]&quot;, template));</span>
    }
<span class="nc" id="L1702">    final StringSubstitutor engine = new StringSubstitutor(data)</span>
<span class="nc" id="L1703">        .setEnableUndefinedVariableException(true)</span>
<span class="nc" id="L1704">        .setPreserveEscapes(true)</span>
<span class="nc" id="L1705">        .setEscapeChar('\\');</span>
    try {
<span class="nc" id="L1707">      Files.write(script,</span>
<span class="nc" id="L1708">          Files.lines(template, sourceEncoding)</span>
<span class="nc" id="L1709">              .map(line -&gt; engine.replace(line).replace(&quot;\\$&quot;, &quot;$&quot;))</span>
<span class="nc" id="L1710">              .collect(Collectors.toList()),</span>
          sourceEncoding);
<span class="nc" id="L1712">    } catch (IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1714">        getLog().error(MessageFormat.format(</span>
            &quot;Variable not found in the launcher template file: [{0}]&quot;,
            template), ex);
      }
<span class="nc" id="L1718">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Variable not found in the launcher template file: [{0}]&quot;, template),
          ex);
<span class="nc" id="L1721">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1723">        getLog().error(MessageFormat.format(</span>
            &quot;Unable to write to the launcher script file: [{0}]&quot;, script), ex);
      }
<span class="nc" id="L1726">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Unable to write to the launcher script file: [{0}]&quot;, script), ex);
<span class="nc" id="L1728">    }</span>
<span class="nc" id="L1729">  }</span>

  /**
   * Execute goal.
   *
   * @throws MojoExecutionException if any errors occurred
   */
  @Override
  public void execute() throws MojoExecutionException {

    // Init
<span class="nc" id="L1740">    init(TOOL_NAME, TOOL_HOME_BIN); // from BaseToolMojo</span>

    // Check version
<span class="nc bnc" id="L1743" title="All 2 branches missed.">    if (!toolJavaVersion.atLeast(JavaVersion.JAVA_9)) {</span>
<span class="nc" id="L1744">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: At least {0} is required to use [{1}]&quot;, JavaVersion.JAVA_9,
          TOOL_NAME));
    }

    // Create mods directory
    try {
<span class="nc" id="L1751">      FileUtils.forceMkdir(modsdir);</span>
<span class="nc" id="L1752">    } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc" id="L1753">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to create mods directory: [{0}]&quot;, modsdir), ex);
<span class="nc" id="L1755">    }</span>

    // Create libs directory
    try {
<span class="nc" id="L1759">      FileUtils.forceMkdir(libsdir);</span>
<span class="nc" id="L1760">    } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc" id="L1761">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to create libs directory: [{0}]&quot;, libsdir), ex);
<span class="nc" id="L1763">    }</span>

    // Delete image output directory if it exists
<span class="nc bnc" id="L1766" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1767">      getLog().info(MessageFormat.format(</span>
          &quot;Set image output directory to: [{0}]&quot;, output));
    }
<span class="nc bnc" id="L1770" title="All 4 branches missed.">    if (output.exists() &amp;&amp; output.isDirectory()) {</span>
      try {
<span class="nc" id="L1772">        FileUtils.deleteDirectory(output);</span>
<span class="nc" id="L1773">      } catch (IOException ex) {</span>
<span class="nc" id="L1774">        throw new MojoExecutionException(MessageFormat.format(</span>
            &quot;Error: Unable to delete image output directory: [{0}]&quot;, output),
            ex);
<span class="nc" id="L1777">      }</span>
    }

    // Resolve and fetch project dependencies
<span class="nc" id="L1781">    projectDependencies = resolveDependencies();</span>
<span class="nc" id="L1782">    mainModuleDescriptor = fetchMainModuleDescriptor();</span>
<span class="nc" id="L1783">    classpathElements = fetchClasspathElements();</span>
<span class="nc" id="L1784">    modulepathElements = fetchModulepathElements();</span>
<span class="nc" id="L1785">    pathExceptions = fetchPathExceptions();</span>
<span class="nc bnc" id="L1786" title="All 4 branches missed.">    if (!pathExceptions.isEmpty() &amp;&amp; getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1787">      getLog().warn(&quot;Found path exceptions: &quot; + pathExceptions.size()</span>
<span class="nc" id="L1788">          + System.lineSeparator()</span>
<span class="nc" id="L1789">          + pathExceptions.entrySet().stream()</span>
<span class="nc" id="L1790">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc" id="L1791">                  + System.lineSeparator()</span>
<span class="nc" id="L1792">                  + entry.getValue())</span>
<span class="nc" id="L1793">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }

    // copy dependencies
<span class="nc" id="L1797">    copyFiles(modulepathElements, modsdir);</span>
<span class="nc" id="L1798">    copyFiles(classpathElements, libsdir);</span>

    // Build command line and populate the list of the command options
<span class="nc" id="L1801">    final CommandLineBuilder cmdLineBuilder = new CommandLineBuilder();</span>
<span class="nc" id="L1802">    cmdLineBuilder.setExecutable(toolExecutable.toString());</span>
<span class="nc" id="L1803">    processOptions(cmdLineBuilder);</span>
<span class="nc" id="L1804">    processModules(cmdLineBuilder);</span>
<span class="nc" id="L1805">    final List&lt;String&gt; optsLines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1806">    optsLines.add(&quot;# &quot; + TOOL_NAME);</span>
<span class="nc" id="L1807">    optsLines.addAll(cmdLineBuilder.buildOptionList());</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1809">      getLog().debug(optsLines.stream()</span>
<span class="nc" id="L1810">          .collect(Collectors.joining(System.lineSeparator(),</span>
<span class="nc" id="L1811">              System.lineSeparator(), &quot;&quot;)));</span>
    }

    // Save the list of command options to the file
    // will be used in the tool command line
<span class="nc" id="L1816">    final Path cmdOptsPath = buildDir.toPath().resolve(OPTS_FILE);</span>
    try {
<span class="nc" id="L1818">      Files.write(cmdOptsPath, optsLines, sourceEncoding);</span>
<span class="nc" id="L1819">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1821">        getLog().error(MessageFormat.format(</span>
            &quot;Unable to write command options to file: [{0}]&quot;, cmdOptsPath), ex);
      }
<span class="nc" id="L1824">    }</span>

    // Prepare command line with command options
    // specified in the file created early
<span class="nc" id="L1828">    final Commandline cmdLine = new Commandline();</span>
<span class="nc" id="L1829">    cmdLine.setExecutable(toolExecutable.toString());</span>
<span class="nc" id="L1830">    cmdLine.createArg().setValue(&quot;@&quot; + cmdOptsPath.toString());</span>

    // Execute command line
<span class="nc" id="L1833">    int exitCode = 0;</span>
    try {
<span class="nc" id="L1835">      exitCode = execCmdLine(cmdLine); // from BaseToolMojo</span>
<span class="nc" id="L1836">    } catch (CommandLineException ex) {</span>
<span class="nc" id="L1837">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to execute [{0}] tool&quot;, TOOL_NAME), ex);
<span class="nc" id="L1839">    }</span>
<span class="nc bnc" id="L1840" title="All 2 branches missed.">    if (exitCode != 0) {</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1842">        getLog().error(System.lineSeparator()</span>
            + &quot;Command options was: &quot;
<span class="nc" id="L1844">            + System.lineSeparator()</span>
<span class="nc" id="L1845">            + optsLines.stream()</span>
<span class="nc" id="L1846">                .collect(Collectors.joining(System.lineSeparator())));</span>
      }
<span class="nc" id="L1848">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Tool execution failed [{0}] with exit code: {1}&quot;, TOOL_NAME,
<span class="nc" id="L1850">          exitCode));</span>
    }

    // Process launcher scripts
<span class="nc" id="L1854">    processLauncherScripts();</span>

    // Delete temporary file
    try {
<span class="nc" id="L1858">      FileUtils.forceDeleteOnExit(cmdOptsPath.toFile());</span>
<span class="nc" id="L1859">    } catch (IOException ex) {</span>
<span class="nc" id="L1860">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to delete temporary file: [{0}]&quot;, cmdOptsPath), ex);
<span class="nc" id="L1862">    }</span>

<span class="nc" id="L1864">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>