<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JlinkMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JLink Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">ru.akman.maven.plugins.jlink</a> &gt; <span class="el_source">JlinkMojo.java</span></div><h1>JlinkMojo.java</h1><pre class="source lang-java linenums">/*
  Copyright (C) 2020 Alexander Kapitman

  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

package ru.akman.maven.plugins.jlink;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.JavaVersion;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringSubstitutor;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Execute;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.shared.model.fileset.FileSet;
import org.codehaus.plexus.languages.java.jpms.JavaModuleDescriptor;
import org.codehaus.plexus.languages.java.jpms.LocationManager;
import org.codehaus.plexus.languages.java.jpms.ModuleNameSource;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsRequest;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsResult;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.cli.CommandLineException;
import org.codehaus.plexus.util.cli.Commandline;
import ru.akman.maven.plugins.BaseToolMojo;
import ru.akman.maven.plugins.CommandLineBuilder;
import ru.akman.maven.plugins.CommandLineOption;

/**
 * The jlink goal lets you create a custom runtime image with
 * the jlink tool introduced in Java 9. It used to link a set of modules,
 * along with their transitive dependences.
 *
 * &lt;p&gt;
 * The main idea is to avoid being tied to project artifacts and allow the user
 * to fully control the process of creating an image. However, it is possible,
 * of course, to customize the process using project artifacts.
 * &lt;/p&gt;
 */
@Mojo(
    name = &quot;jlink&quot;,
    defaultPhase = LifecyclePhase.PACKAGE,
    requiresDependencyResolution = ResolutionScope.RUNTIME
//    requiresProject = true
//    aggregator = &lt;false|true&gt;,
//    configurator = &quot;&lt;role hint&gt;&quot;,
//    executionStrategy = &quot;&lt;once-per-session|always&gt;&quot;,
//    inheritByDefault = &lt;true|false&gt;,
//    instantiationStrategy = InstantiationStrategy.&lt;strategy&gt;,
//    requiresDependencyCollection = ResolutionScope.&lt;scope&gt;,
//    requiresDirectInvocation = &lt;false|true&gt;,
//    requiresOnline = &lt;false|true&gt;,
//    threadSafe = &lt;false|true&gt;
)
@Execute(
    // This will fork an alternate build lifecycle up to the specified phase
    // before continuing to execute the current one.
    // If no lifecycle is specified, Maven will use the lifecycle
    // of the current build.
    phase = LifecyclePhase.PACKAGE
//
//    This will execute the given goal before execution of this one.
//    The goal name is specified using the prefix:goal notation.
//    goal = &quot;prefix:goal&quot;
//
//    This will execute the given alternate lifecycle. A custom lifecycle
//    can be defined in META-INF/maven/lifecycle.xml.
//    lifecycle = &quot;&lt;lifecycle&gt;&quot;, phase=&quot;&lt;phase&gt;&quot;
)
<span class="fc" id="L102">public class JlinkMojo extends BaseToolMojo {</span>

  /**
   * The name of the subdirectory where the tool live.
   */
  private static final String TOOL_HOME_BIN = &quot;bin&quot;;

  /**
   * The tool name.
   */
  private static final String TOOL_NAME = &quot;jlink&quot;;

  /**
   * Filename for temporary file contains the tool options.
   */
  private static final String OPTS_FILE = TOOL_NAME + &quot;.opts&quot;;

  /**
   * Filename of a module descriptor.
   */
  private static final String DESCRIPTOR_NAME = &quot;module-info.class&quot;;

  /*
   * Following fields inherit from BaseToolMojo
   * ==========================================
   *
   * Maven project.
   * MavenProject project;
   *
   * Maven session.
   * MavenSession session;
   *
   * All JDK toolchains available in user settings
   * independently from maven-toolchains-plugin.
   * List&lt;Toolchain&gt; toolchains;
   *
   * JDK toolchain from build context,
   * i.e. the toolchain selected by maven-toolchains-plugin.
   * Toolchain toolchain;
   *
   * Toolchain manager.
   * ToolchainManager toolchainManager;
   *
   * Build plugin manager.
   * BuildPluginManager pluginManager;
   *
   * Fileset manager.
   * FileSetManager fileSetManager;
   *
   * Project properties.
   * Properties properties;
   *
   * Default charset (${project.build.sourceEncoding}).
   * Charset sourceEncoding = Charset.defaultCharset();
   *
   * Project base directory (that containing the pom.xml file).
   * File baseDir;
   *
   * Project build directory (${project.basedir}/target).
   * File buildDir;
   *
   * Project output directory (${project.build.directory}/classes).
   * File outputDir;
   *
   * Tool home directory.
   * File toolHomeDir;
   *
   * Tool executable.
   * File toolExecutable;
   *
   * Tool version.
   * String toolVersion;
   *
   * Tool corresponding java version.
   * JavaVersion toolJavaVersion;
   */

  /**
   * Resolved project dependencies.
   */
  private ResolvePathsResult&lt;File&gt; projectDependencies;

  /**
   * Resolved main module descriptor.
   */
  private JavaModuleDescriptor mainModuleDescriptor;

  /**
   * Path exceptions (not resolved dependencies).
   */
  private Map&lt;File, String&gt; pathExceptions;

  /**
   * Classpath elements (classpath dependencies).
   */
  private List&lt;File&gt; classpathElements;

  /**
   * Modulepath elements (modulepath dependencies).
   */
  private List&lt;File&gt; modulepathElements;

  /**
   * JPMS location manager.
   */
  @Component
  private LocationManager locationManager;

  /**
   * Specifies the path to the JDK home directory providing the tool needed.
   */
  @Parameter
  private File toolhome;

  /**
   * Specifies the location in which modular dependencies will be copied.
   *
   * &lt;p&gt;Default value: ${project.build.directory}/jlink/mods.&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/mods&quot;
  )
  private File modsdir;

  /**
   * Specifies the location in which non modular dependencies will be copied.
   *
   * &lt;p&gt;Default value: ${project.build.directory}/jlink/libs.&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/libs&quot;
  )
  private File libsdir;

  /**
   * Specifies the module path. The path where the jlink tool discovers
   * observable modules: modular JAR files, JMOD files, exploded modules.
   * If this option is not specified, then the default module path
   * is $JAVA_HOME/jmods. This directory contains the java.base module
   * and the other standard and JDK modules. If this option is specified
   * but the java.base module cannot be resolved from it, then
   * the jlink command appends $JAVA_HOME/jmods to the module path.
   *
   * &lt;p&gt;
   * pathelements - passed to jlink as is
   * filesets - sets of files (without directories)
   * dirsets - sets of directories (without files)
   * dependencysets - sets of dependencies with specified includes and
   *                  excludes patterns (glob: or regex:) for file names
   *                  and regex patterns only for module names
   * &lt;/p&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;modulepath&amp;gt;
   *   &amp;lt;pathelements&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jar&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jmod&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mods/exploded/mod&amp;lt;/pathelement&amp;gt;
   *   &amp;lt;/pathelements&amp;gt;
   *   &amp;lt;filesets&amp;gt;
   *     &amp;lt;fileset&amp;gt;
   *       &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Empty.jar&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;false&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/fileset&amp;gt;
   *   &amp;lt;/filesets&amp;gt;
   *   &amp;lt;dirsets&amp;gt;
   *     &amp;lt;dirset&amp;gt;
   *       &amp;lt;directory&amp;gt;target&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Test&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;true&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/dirset&amp;gt;
   *   &amp;lt;/dirsets&amp;gt;
   *   &amp;lt;dependencysets&amp;gt;
   *     &amp;lt;dependencyset&amp;gt;
   *       &amp;lt;includeoutput&amp;gt;false&amp;lt;/includeoutput&amp;gt;
   *       &amp;lt;excludeautomatic&amp;gt;false&amp;lt;/excludeautomatic&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;glob:*&amp;#42;/*.jar&amp;lt;/include&amp;gt;
   *         &amp;lt;include&amp;gt;regex:foo-(bar|baz)-.*?\.jar&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;includenames&amp;gt;
   *         &amp;lt;includename&amp;gt;.*&amp;lt;/includename&amp;gt;
   *       &amp;lt;/includenames&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;glob:*&amp;#42;/javafx.*Empty&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;excludenames&amp;gt;
   *         &amp;lt;excludename&amp;gt;javafx\..+Empty&amp;lt;/excludename&amp;gt;
   *       &amp;lt;/excludenames&amp;gt;
   *     &amp;lt;/dependencyset&amp;gt;
   *   &amp;lt;/dependencysets&amp;gt;
   * &amp;lt;/modulepath&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--modulepath path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private ModulePath modulepath;

  /**
   * Specifies the modules names (names of root modules) to add to
   * the runtime image. Their transitive dependencies will add too.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;addmodules&amp;gt;
   *   &amp;lt;addmodule&amp;gt;java.base&amp;lt;/addmodule&amp;gt;
   *   &amp;lt;addmodule&amp;gt;org.example.rootmodule&amp;lt;/addmodule&amp;gt;
   * &amp;lt;/addmodules&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--add-modules module [, module...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; addmodules;

  /**
   * Specifies the location of the generated runtime image.
   *
   * &lt;p&gt;Default value: ${project.build.directory}/jlink/image.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--output path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jlink/image&quot;
  )
  private File output;

  /**
   * Limits the universe of observable modules to those in
   * the transitive closure of the named modules, mod,
   * plus the main module, if any, plus any further
   * modules specified in the &quot;addmodules&quot; property.
   * It used to limit resolve any services other than
   * the selected services, if the property &quot;bindservices&quot;
   * set to true.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;limitmodules&amp;gt;
   *   &amp;lt;limitmodule&amp;gt;java.base&amp;lt;/limitmodule&amp;gt;
   *   &amp;lt;limitmodule&amp;gt;org.example.limitmodule&amp;lt;/limitmodule&amp;gt;
   * &amp;lt;/limitmodules&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--limit-modules module [, module...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; limitmodules;

  /**
   * Suggest providers that implement the given service types
   * from the module path.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;suggestproviders&amp;gt;
   *   &amp;lt;suggestprovider&amp;gt;provider.name&amp;lt;/suggestprovider&amp;gt;
   * &amp;lt;/suggestproviders&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--suggest-providers [name, ...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; suggestproviders;

  /**
   * Save jlink options in the given file.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--save-opts filename&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File saveopts;

  /**
   * The last plugin allowed to sort resources.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--resources-last-sorter name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String resourceslastsorter;

  /**
   * Post process an existing image.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--post-process-path imagefile&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File postprocesspath;

  /**
   * Enable verbose tracing.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--verbose&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean verbose;

  /**
   * Link service provider modules and their dependencies.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--bind-services&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean bindservices;

  /**
   * Specifies the launcher command name for the module (and the main class).
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;launcher&amp;gt;
   *   &amp;lt;command&amp;gt;mylauncher&amp;lt;/command&amp;gt;
   *   &amp;lt;mainmodule&amp;gt;mainModule&amp;lt;/mainmodule&amp;gt;
   *   &amp;lt;mainclass&amp;gt;mainClass&amp;lt;/mainclass&amp;gt;
   * &amp;lt;/launcher&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--launcher command=main-module[/main-class]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Launcher launcher;

  /**
   * Excludes header files.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--no-header-files&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean noheaderfiles;

  /**
   * Excludes man pages.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--no-man-pages&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean nomanpages;

  /**
   * Specifies the byte order of the generated image: { NATIVE | LITTLE | BIG }.
   *
   * &lt;p&gt;Default value: NATIVE (the format of your system's architecture).&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--endian {little|big}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;NATIVE&quot;
  )
  private Endian endian;

  /**
   * Suppresses a fatal error when signed modular JARs are linked
   * in the runtime image. The signature-related files of the signed
   * modular JARs aren't copied to the runtime image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--ignore-signing-information&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean ignoresigninginformation;

  /**
   * Disables the specified plug-ins.
   * For a complete list of all available plug-ins,
   * run the command: &lt;code&gt;jlink --list-plugins&lt;/code&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;disableplugins&amp;gt;
   *   &amp;lt;disableplugin&amp;gt;compress&amp;lt;/disableplugin&amp;gt;
   *   &amp;lt;disableplugin&amp;gt;dedup-legal-notices&amp;lt;/disableplugin&amp;gt;
   * &amp;lt;/disableplugins&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--disable-plugin pluginname&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; disableplugins;

  /*
    For plug-in options that require a pattern-list, the value is
    a comma-separated list of elements, with each element using one
    the following forms:

      - glob-pattern
      - glob:glob-pattern
      - regex:regex-pattern
      - @filename

    Example: *&amp;#42;/module-info.class,glob:/java.base/java/lang/**,@file
  */

  /**
   * Compresses all resources in the output image. Specify
   * compression { NO_COMPRESSION | CONSTANT_STRING_SHARING | ZIP }.
   * An optional pattern-list filter can be specified to list
   * the pattern of files to include.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;compress&amp;gt;
   *   &amp;lt;compression&amp;gt;ZIP&amp;lt;/compression&amp;gt;
   *   &amp;lt;filters&amp;gt;
   *     &amp;lt;filter&amp;gt;*&amp;#42;/*-info.class&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;regex:/java[a-z]+$&amp;lt;/filter&amp;gt;
   *     &amp;lt;filter&amp;gt;@filename&amp;lt;/filter&amp;gt;
   *   &amp;lt;/filters&amp;gt;
   * &amp;lt;/compress&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--compress={0|1|2}[:filter=pattern-list]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Compress compress;

  /**
   * Includes the list of locales where langtag is
   * a BCP 47 language tag. This option supports locale matching as
   * defined in RFC 4647. CAUTION! Ensure that you specified:
   * &lt;code&gt;‒‒add-modules jdk.localedata&lt;/code&gt; when using this property.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;includelocales&amp;gt;
   *   &amp;lt;includelocale&amp;gt;en&amp;lt;/includelocale&amp;gt;
   *   &amp;lt;includelocale&amp;gt;ja&amp;lt;/includelocale&amp;gt;
   *   &amp;lt;includelocale&amp;gt;*-IN&amp;lt;/includelocale&amp;gt;
   * &amp;lt;/includelocales&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--include-locales=langtag[,langtag ...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; includelocales;

  /**
   * Orders the specified paths in priority order.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;orderresources&amp;gt;
   *   &amp;lt;orderresource&amp;gt;*&amp;#42;/*-info.class&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;regex:/java[a-z]+$&amp;lt;/orderresource&amp;gt;
   *   &amp;lt;orderresource&amp;gt;@filename&amp;lt;/orderresource&amp;gt;
   * &amp;lt;/orderresources&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--order-resources=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; orderresources;

  /**
   * Specify resources to exclude.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;excluderesources&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;*&amp;#42;/*-info.class&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;regex:/java[a-z]+$&amp;lt;/excluderesource&amp;gt;
   *   &amp;lt;excluderesource&amp;gt;@filename&amp;lt;/excluderesource&amp;gt;
   * &amp;lt;/excluderesources&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--order-resources=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; excluderesources;

  /**
   * Strips debug information from the output image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-debug&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripdebug;

  /**
   * Strip Java debug attributes from classes in the output image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-java-debug-attributes&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripjavadebugattributes;

  /**
   * Exclude native commands (such as java/java.exe) from the image.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--strip-native-commands&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean stripnativecommands;

  /**
   * De-duplicate all legal notices. If true is specified then
   * it will be an error if two files of the same filename
   * are different.
   *
   * &lt;p&gt;Default value: false.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is:
   * &lt;code&gt;--dedup-legal-notices=error-if-not-same-content&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean deduplegalnotices;

  /**
   * Specify files to exclude.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;excludefiles&amp;gt;
   *   &amp;lt;excludefile&amp;gt;*&amp;#42;/*-info.class&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;glob:*&amp;#42;/module-info.class&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;regex:/java[a-z]+$&amp;lt;/excludefile&amp;gt;
   *   &amp;lt;excludefile&amp;gt;@filename&amp;lt;/excludefile&amp;gt;
   * &amp;lt;/excludefiles&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--exclude-files=pattern-list&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; excludefiles;

  /**
   * Specify a JMOD section to exclude { MAN | HEADERS }.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--exclude-jmod-section={man|headers}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private Section excludejmodsection;

  /**
   * Specify a file listing the java.lang.invoke classes to pre-generate.
   * By default, this plugin may use a builtin list of classes
   * to pre-generate. If this plugin runs on a different runtime
   * version than the image being created then code generation
   * will be disabled by default to guarantee correctness add
   * ignore-version=true to override this.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--generate-jli-classes=@filename&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File generatejliclasses;

  /**
   * Load release properties from the supplied option file.
   * - adds: is to add properties to the release file.
   * - dels: is to delete the list of keys in release file.
   * - Any number of key=value pairs can be passed.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;releaseinfo&amp;gt;
   *   &amp;lt;file&amp;gt;file&amp;lt;/file&amp;gt;
   *   &amp;lt;adds&amp;gt;
   *     &amp;lt;key1&amp;gt;value1&amp;lt;/key1&amp;gt;
   *     &amp;lt;key2&amp;gt;value2&amp;lt;/key2&amp;gt;
   *   &amp;lt;/adds&amp;gt;
   *   &amp;lt;dells&amp;gt;
   *     &amp;lt;key1 /&amp;gt;
   *     &amp;lt;key2 /&amp;gt;
   *   &amp;lt;/dells&amp;gt;
   * &amp;lt;/releaseinfo&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;/p&gt;The jlink CLI is:
   * &lt;code&gt;--release-info=file|add:key1=value1:key2=value2:...|del:key-list
   * &lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private ReleaseInfo releaseinfo;

  // /**
  //  * Fast loading of module descriptors. Always on.
  //  *
  //  * &lt;p&gt;Default value: true.&lt;/p&gt;
  //  *
  //  * &lt;p&gt;The jlink CLI is: &lt;code&gt;--system-modules=&lt;/code&gt;&lt;/p&gt;
  //  */
  // @Parameter(
  //     defaultValue = &quot;true&quot;
  // )
  // private boolean systemmodules;

  /**
   * Select the HotSpot VM in
   * the output image: { CLIENT | SERVER | MINIMAL | ALL }.
   *
   * &lt;p&gt;Default is ALL.&lt;/p&gt;
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--vm={client|server|minimal|all}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private HotSpot vm;

  /**
   * Resolve project dependencies.
   *
   * @return map of the resolved project dependencies
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                dependencies
   */
  private ResolvePathsResult&lt;File&gt; resolveDependencies()
      throws MojoExecutionException {

    // get project artifacts - all dependencies that this project has,
    // including transitive ones (depends on what phases have run)
<span class="nc" id="L751">    final Set&lt;Artifact&gt; artifacts = project.getArtifacts();</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L753">      getLog().debug(PluginUtils.getArtifactSetDebugInfo(artifacts));</span>
    }

    // create a list of the paths which will be resolved
<span class="nc" id="L757">    final List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>

    // add the project output directory
<span class="nc" id="L760">    paths.add(outputDir);</span>

    // SCOPE_COMPILE  - This is the default scope, used if none is specified.
    //                  Compile dependencies are available in all classpaths.
    //                  Furthermore, those dependencies are propagated to
    //                  dependent projects.
    // SCOPE_PROVIDED - This is much like compile, but indicates you expect
    //                  the JDK or a container to provide it at runtime.
    //                  It is only available on the compilation and
    //                  test classpath, and is not transitive.
    // SCOPE_SYSTEM   - This scope is similar to provided except that you
    //                  have to provide the JAR which contains it explicitly.
    //                  The artifact is always available and is not looked up
    //                  in a repository.    
    // SCOPE_RUNTIME  - This scope indicates that the dependency is not
    //                  required for compilation, but is for execution.
    //                  It is in the runtime and test classpaths, but not
    //                  the compile classpath.
    // SCOPE_TEST     - This scope indicates that the dependency is not
    //                  required for normal use of the application, and is
    //                  only available for the test compilation and execution
    //                  phases. It is not transitive.
    // SCOPE_IMPORT   - This scope indicates that the dependency is a managed
    //                  POM dependency i.e. only other POM into
    //                  the dependencyManagement section.

    // [ !SCOPE_TEST ] add the project artifacts files
<span class="nc" id="L787">    paths.addAll(artifacts.stream()</span>
<span class="nc bnc" id="L788" title="All 4 branches missed.">        .filter(a -&gt; a != null &amp;&amp; !Artifact.SCOPE_TEST.equals(a.getScope()))</span>
<span class="nc" id="L789">        .map(a -&gt; a.getFile())</span>
<span class="nc" id="L790">        .collect(Collectors.toList()));</span>

    // [ SCOPE_SYSTEM ] add the project system dependencies
    // getSystemPath() is used only if the dependency scope is system
<span class="nc" id="L794">    paths.addAll(project.getDependencies().stream()</span>
<span class="nc bnc" id="L795" title="All 4 branches missed.">        .filter(d -&gt; d != null &amp;&amp; !StringUtils.isBlank(d.getSystemPath()))</span>
<span class="nc" id="L796">        .map(d -&gt; new File(StringUtils.stripToEmpty(d.getSystemPath())))</span>
<span class="nc" id="L797">        .collect(Collectors.toList()));</span>

    // create request contains all information
    // required to analyze the project
<span class="nc" id="L801">    final ResolvePathsRequest&lt;File&gt; request =</span>
<span class="nc" id="L802">        ResolvePathsRequest.ofFiles(paths);</span>

    // this is used to resolve main module descriptor
<span class="nc" id="L805">    final File descriptorFile =</span>
<span class="nc" id="L806">        outputDir.toPath().resolve(DESCRIPTOR_NAME).toFile();</span>
<span class="nc bnc" id="L807" title="All 4 branches missed.">    if (descriptorFile.exists() &amp;&amp; !descriptorFile.isDirectory()) {</span>
<span class="nc" id="L808">      request.setMainModuleDescriptor(descriptorFile);</span>
    }

    // this is used to extract the module name
<span class="nc bnc" id="L812" title="All 2 branches missed.">    if (toolHomeDir != null) {</span>
<span class="nc" id="L813">      request.setJdkHome(toolHomeDir);</span>
    }

    // resolve project dependencies
    try {
<span class="nc" id="L818">      return locationManager.resolvePaths(request);</span>
<span class="nc" id="L819">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L821">        getLog().error(&quot;Unable to resolve project dependencies&quot;, ex);</span>
      }
<span class="nc" id="L823">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to resolve project dependencies&quot;, ex);
    }

  }

  /**
   * Fetch the resolved main module descriptor.
   *
   * @return main module descriptor or null if it not exists
   */
  private JavaModuleDescriptor fetchMainModuleDescriptor() {
<span class="nc" id="L835">    final JavaModuleDescriptor descriptor =</span>
<span class="nc" id="L836">        projectDependencies.getMainModuleDescriptor();</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">    if (descriptor == null) {</span>
      // detected that the project is non modular
<span class="nc bnc" id="L839" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L840">        getLog().warn(&quot;The main module descriptor not found&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L843" title="All 2 branches missed.">      if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L844">        getLog().info(MessageFormat.format(</span>
<span class="nc" id="L845">            &quot;Found the main module descriptor: [{0}]&quot;, descriptor.name()));</span>
      }
    }
<span class="nc" id="L848">    return descriptor;</span>
  }

  /**
   * Fetch path exceptions for every modulename which resolution failed.
   *
   * @return pairs of path exception file and cause
   */
  private Map&lt;File, String&gt; fetchPathExceptions() {
<span class="nc" id="L857">    return projectDependencies.getPathExceptions()</span>
<span class="nc" id="L858">        .entrySet().stream()</span>
<span class="nc bnc" id="L859" title="All 4 branches missed.">        .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L860">        .collect(Collectors.toMap(</span>
<span class="nc" id="L861">            entry -&gt; entry.getKey(),</span>
<span class="nc" id="L862">            entry -&gt; PluginUtils.getThrowableCause(entry.getValue())</span>
        ));
  }

  /**
   * Fetch classpath elements.
   *
   * @return classpath elements
   */
  private List&lt;File&gt; fetchClasspathElements() {
<span class="nc" id="L872">    final List&lt;File&gt; result = projectDependencies.getClasspathElements()</span>
<span class="nc" id="L873">        .stream()</span>
<span class="nc" id="L874">        .filter(Objects::nonNull)</span>
<span class="nc" id="L875">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L877">      getLog().info(&quot;Found classpath elements: &quot; + result.size()</span>
<span class="nc" id="L878">          + System.lineSeparator()</span>
<span class="nc" id="L879">          + result.stream()</span>
<span class="nc" id="L880">              .map(file -&gt; file.toString())</span>
<span class="nc" id="L881">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L883">    return result;</span>
  }

  /**
   * Fetch modulepath elements.
   *
   * @return modulepath elements
   */
  private List&lt;File&gt; fetchModulepathElements() {
<span class="nc" id="L892">    final List&lt;File&gt; result = projectDependencies.getModulepathElements()</span>
<span class="nc" id="L893">        .keySet()</span>
<span class="nc" id="L894">        .stream()</span>
<span class="nc" id="L895">        .filter(Objects::nonNull)</span>
<span class="nc" id="L896">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L898">      getLog().info(&quot;Found modulepath elements: &quot; + result.size()</span>
<span class="nc" id="L899">          + System.lineSeparator()</span>
<span class="nc" id="L900">          + projectDependencies.getModulepathElements().entrySet().stream()</span>
<span class="nc bnc" id="L901" title="All 4 branches missed.">              .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L902">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                  + (ModuleNameSource.FILENAME.equals(entry.getValue())</span>
<span class="nc" id="L904">                      ? System.lineSeparator()</span>
                          + &quot;[!] Detected 'requires' filename based &quot;
                          + &quot;automatic module&quot;
<span class="nc" id="L907">                          + System.lineSeparator()</span>
                          + &quot;[!] Please don't publish this project to &quot;
                          + &quot;a public artifact repository&quot;
<span class="nc" id="L910">                          + System.lineSeparator()</span>
                          + (mainModuleDescriptor != null
<span class="nc bnc" id="L912" title="All 4 branches missed.">                              &amp;&amp; mainModuleDescriptor.exports().isEmpty()</span>
<span class="nc" id="L913">                                  ? &quot;[!] APPLICATION&quot;</span>
<span class="nc" id="L914">                                  : &quot;[!] LIBRARY&quot;)</span>
<span class="nc" id="L915">                      : &quot;&quot;))</span>
<span class="nc" id="L916">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L918">    return result;</span>
  }

  /**
   * Get path from the pathelements parameter.
   *
   * @return path contains parameter elements
   */
  private String getPathElements() {
<span class="nc" id="L927">    String result = null;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L929">      final List&lt;File&gt; pathelements = modulepath.getPathElements();</span>
<span class="nc bnc" id="L930" title="All 4 branches missed.">      if (pathelements != null &amp;&amp; !pathelements.isEmpty()) {</span>
<span class="nc" id="L931">        result = pathelements.stream()</span>
<span class="nc" id="L932">            .filter(Objects::nonNull)</span>
<span class="nc" id="L933">            .map(file -&gt; file.toString())</span>
<span class="nc" id="L934">            .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">        if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L936">          getLog().debug(PluginUtils.getPathElementsDebugInfo(&quot;PATHELEMENTS&quot;,</span>
              pathelements));
<span class="nc" id="L938">          getLog().debug(result);</span>
        }
      }
    }
<span class="nc" id="L942">    return result;</span>
  }

  /**
   * Get filesets from modulepath parameter.
   *
   * @return path contains filesets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a fileset
   */
  private String getFileSets() throws MojoExecutionException {
<span class="nc" id="L954">    String result = null;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L956">      final List&lt;FileSet&gt; filesets = modulepath.getFileSets();</span>
<span class="nc bnc" id="L957" title="All 4 branches missed.">      if (filesets != null &amp;&amp; !filesets.isEmpty()) {</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">        for (final FileSet fileSet : filesets) {</span>
          final File fileSetDir;
          try {
<span class="nc" id="L961">            fileSetDir = PluginUtils.normalizeFileSetBaseDir(baseDir, fileSet);</span>
<span class="nc" id="L962">          } catch (IOException ex) {</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L964">              getLog().error(&quot;Unable to resolve fileset&quot;, ex);</span>
            }
<span class="nc" id="L966">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve fileset&quot;, ex);
<span class="nc" id="L968">          }</span>
<span class="nc" id="L969">          result = Stream.of(fileSetManager.getIncludedFiles(fileSet))</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">              .filter(fileName -&gt; !StringUtils.isBlank(fileName))</span>
<span class="nc" id="L971">              .map(fileName -&gt; fileSetDir.toPath().resolve(</span>
<span class="nc" id="L972">                  StringUtils.stripToEmpty(fileName)).toString())</span>
<span class="nc" id="L973">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L975">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;FILESET&quot;,</span>
                fileSet, result));
          }
<span class="nc" id="L978">        }</span>
      }
    }
<span class="nc" id="L981">    return result;</span>
  }

  /**
   * Get dirsets from modulepath parameter.
   *
   * @return path contains dirsets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a dirset
   */
  private String getDirSets() throws MojoExecutionException {
<span class="nc" id="L993">    String result = null;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L995">      final List&lt;FileSet&gt; dirsets = modulepath.getDirSets();</span>
<span class="nc bnc" id="L996" title="All 4 branches missed.">      if (dirsets != null &amp;&amp; !dirsets.isEmpty()) {</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">        for (final FileSet dirSet : dirsets) {</span>
          final File dirSetDir;
          try {
<span class="nc" id="L1000">            dirSetDir = PluginUtils.normalizeFileSetBaseDir(baseDir, dirSet);</span>
<span class="nc" id="L1001">          } catch (IOException ex) {</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">            if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1003">              getLog().error(&quot;Unable to resolve dirset&quot;, ex);</span>
            }
<span class="nc" id="L1005">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve dirset&quot;, ex);
<span class="nc" id="L1007">          }</span>
<span class="nc" id="L1008">          result = Stream.of(fileSetManager.getIncludedDirectories(dirSet))</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">              .filter(dirName -&gt; !StringUtils.isBlank(dirName))</span>
<span class="nc" id="L1010">              .map(dirName -&gt; dirSetDir.toPath().resolve(</span>
<span class="nc" id="L1011">                  StringUtils.stripToEmpty(dirName)).toString())</span>
<span class="nc" id="L1012">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1014">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;DIRSET&quot;,</span>
                dirSet, result));
          }
<span class="nc" id="L1017">        }</span>
      }
    }
<span class="nc" id="L1020">    return result;</span>
  }

  /**
   * Get dependencysets from modulepath parameter.
   *
   * @return path contains dependencysets
   */
  private String getDependencySets() {
<span class="nc" id="L1029">    String result = null;</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1031">      final List&lt;DependencySet&gt; dependencysets =</span>
<span class="nc" id="L1032">          modulepath.getDependencySets();</span>
<span class="nc bnc" id="L1033" title="All 4 branches missed.">      if (dependencysets != null &amp;&amp; !dependencysets.isEmpty()) {</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        for (final DependencySet dependencySet : dependencysets) {</span>
<span class="nc" id="L1035">          result = getIncludedDependencies(dependencySet)</span>
<span class="nc" id="L1036">              .stream()</span>
<span class="nc" id="L1037">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1039">            getLog().debug(PluginUtils.getDependencySetDebugInfo(</span>
                &quot;DEPENDENCYSET&quot;, dependencySet, result));
          }
<span class="nc" id="L1042">        }</span>
      }
    }
<span class="nc" id="L1045">    return result;</span>
  }

  /**
   * Get the included project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the included project dependencies
   */
  private Set&lt;String&gt; getIncludedDependencies(final DependencySet depSet) {
<span class="nc" id="L1057">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">            &amp;&amp; filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L1061">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L1062">        .collect(Collectors.toSet());</span>
  }

  /**
   * Get the excluded project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the excluded project dependencies
   */
  private Set&lt;String&gt; getExcludedDependencies(final DependencySet depSet) {
<span class="nc" id="L1074">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">            &amp;&amp; !filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L1078">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L1079">        .collect(Collectors.toSet());</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the rules defined in the dependencyset.
   * The dependency that matches at least one include pattern will be included,
   * but if the dependency matches at least one exclude pattern too,
   * then the dependency will not be included.
   *
   * @param depSet the dependencyset
   * @param file the dependency file
   * @param descriptor the dependency module descriptor
   *
   * @return will the dependency be accepted
   */
  private boolean filterDependency(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1098" title="All 2 branches missed.">    if (descriptor == null) {</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1100">        getLog().warn(&quot;Missing module descriptor: &quot; + file);</span>
      }
    } else {
<span class="nc bnc" id="L1103" title="All 4 branches missed.">      if (descriptor.isAutomatic() &amp;&amp; getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1104">        getLog().info(&quot;Found automatic module: &quot; + file);</span>
      }
    }

<span class="nc" id="L1108">    boolean isIncluded = false;</span>

<span class="nc bnc" id="L1110" title="All 2 branches missed.">    if (depSet == null) {</span>
      // include module by default
<span class="nc" id="L1112">      isIncluded = true;</span>
      // include automatic module by default
<span class="nc bnc" id="L1114" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">          &amp;&amp; getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1116">        getLog().info(&quot;Included automatic module: &quot; + file);</span>
      }
      // exclude output module by default
<span class="nc bnc" id="L1119" title="All 2 branches missed.">      if (file.compareTo(outputDir) == 0) {</span>
<span class="nc" id="L1120">        isIncluded = false;</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1122">          getLog().info(&quot;Excluded output module: &quot; + file);</span>
        }
      }
    } else {
<span class="nc bnc" id="L1126" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">          &amp;&amp; depSet.isAutomaticExcluded()) {</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">        if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1129">          getLog().info(&quot;Excluded automatic module: &quot; + file);</span>
        }
      } else {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (file.compareTo(outputDir) == 0) {</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">          if (depSet.isOutputIncluded()) {</span>
<span class="nc" id="L1134">            isIncluded = true;</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1136">              getLog().info(&quot;Included output module: &quot; + file);</span>
            }
          } else {
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1140">              getLog().info(&quot;Excluded output module: &quot; + file);</span>
            }
          }
        } else {
<span class="nc bnc" id="L1144" title="All 2 branches missed.">          isIncluded = matchesIncludes(depSet, file, descriptor)</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">              &amp;&amp; !matchesExcludes(depSet, file, descriptor);</span>
        }
      }
    }

<span class="nc bnc" id="L1150" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1151">      getLog().debug(PluginUtils.getDependencyDebugInfo(file, descriptor,</span>
          isIncluded));
    }

<span class="nc" id="L1155">    return isIncluded;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the include patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be included
   */
  private boolean matchesIncludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1172" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1174">    final List&lt;String&gt; includes = depSet.getIncludes();</span>
<span class="nc" id="L1175">    final List&lt;String&gt; includenames = depSet.getIncludeNames();</span>

<span class="nc" id="L1177">    boolean result = true;</span>

<span class="nc bnc" id="L1179" title="All 4 branches missed.">    if (includenames == null || includenames.isEmpty()) {</span>
<span class="nc bnc" id="L1180" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1181">        result = true;</span>
      } else {
<span class="nc" id="L1183">        result = pathMatches(includes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1186" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1187">        result = nameMatches(includenames, name);</span>
      } else {
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        result = pathMatches(includes, file.toPath())</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">            || nameMatches(includenames, name);</span>
      }
    }
<span class="nc" id="L1193">    return result;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the exclude patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be excluded
   */
  private boolean matchesExcludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1210" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1212">    final List&lt;String&gt; excludes = depSet.getExcludes();</span>
<span class="nc" id="L1213">    final List&lt;String&gt; excludenames = depSet.getExcludeNames();</span>

<span class="nc" id="L1215">    boolean result = false;</span>

<span class="nc bnc" id="L1217" title="All 4 branches missed.">    if (excludenames == null || excludenames.isEmpty()) {</span>
<span class="nc bnc" id="L1218" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1219">        result = false;</span>
      } else {
<span class="nc" id="L1221">        result = pathMatches(excludes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1224" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1225">        result = nameMatches(excludenames, name);</span>
      } else {
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        result = pathMatches(excludes, file.toPath())</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">            || nameMatches(excludenames, name);</span>
      }
    }
<span class="nc" id="L1231">    return result;</span>
  }

  /**
   * Checks if the path matches at least one of the patterns.
   * The pattern should be regex or glob, this is determined
   * by the prefix specified in the pattern.
   *
   * @param patterns the list of patterns
   * @param path the file path
   *
   * @return true if the path matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean pathMatches(final List&lt;String&gt; patterns, final Path path) {
<span class="nc bnc" id="L1246" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
      final PathMatcher pathMatcher =
<span class="nc" id="L1248">          FileSystems.getDefault().getPathMatcher(pattern);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">      if (pathMatcher.matches(path)) {</span>
<span class="nc" id="L1250">        return true;</span>
      }
<span class="nc" id="L1252">    }</span>
<span class="nc" id="L1253">    return false;</span>
  }

  /**
   * Checks if the name matches at least one of the patterns.
   * The pattern should be regex only.
   *
   * @param patterns the list of patterns
   * @param name the name
   *
   * @return true if the name matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean nameMatches(final List&lt;String&gt; patterns, final String name) {
<span class="nc bnc" id="L1267" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
<span class="nc" id="L1268">      final Pattern regexPattern = Pattern.compile(pattern);</span>
<span class="nc" id="L1269">      final Matcher nameMatcher = regexPattern.matcher(name);</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">      if (nameMatcher.matches()) {</span>
<span class="nc" id="L1271">        return true;</span>
      }
<span class="nc" id="L1273">    }</span>
<span class="nc" id="L1274">    return false;</span>
  }

  /**
   * Process modules.
   *
   * @param cmdLine the command line builder
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processModules(final CommandLineBuilder cmdLine)
      throws MojoExecutionException {
<span class="nc" id="L1286">    CommandLineOption opt = null;</span>
    // modulepath
<span class="nc bnc" id="L1288" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1289">      final StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1290">      final String pathElements = getPathElements();</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">      if (!StringUtils.isBlank(pathElements)) {</span>
<span class="nc" id="L1292">        path.append(StringUtils.stripToEmpty(pathElements));</span>
      }
<span class="nc" id="L1294">      final String fileSets = getFileSets();</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">      if (!StringUtils.isBlank(fileSets)) {</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1297">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1299">        path.append(StringUtils.stripToEmpty(fileSets));</span>
      }
<span class="nc" id="L1301">      final String dirSets = getDirSets();</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">      if (!StringUtils.isBlank(dirSets)) {</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1304">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1306">        path.append(StringUtils.stripToEmpty(dirSets));</span>
      }
<span class="nc" id="L1308">      final String dependencySets = getDependencySets();</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">      if (!StringUtils.isBlank(dependencySets)) {</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1311">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1313">        path.append(StringUtils.stripToEmpty(dependencySets));</span>
      }
<span class="nc bnc" id="L1315" title="All 2 branches missed.">      if (path.length() != 0) {</span>
<span class="nc" id="L1316">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1317">        opt.createArg().setValue(&quot;--module-path&quot;);</span>
<span class="nc" id="L1318">        opt.createArg().setValue(path.toString());</span>
      }
    }
    // addmodules
<span class="nc bnc" id="L1322" title="All 4 branches missed.">    if (includelocales != null &amp;&amp; !includelocales.isEmpty()) {</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">      if (addmodules == null) {</span>
<span class="nc" id="L1324">        addmodules = new ArrayList&lt;&gt;();</span>
      }
<span class="nc" id="L1326">      addmodules.add(&quot;jdk.localedata&quot;);</span>
    }
<span class="nc bnc" id="L1328" title="All 4 branches missed.">    if (addmodules != null &amp;&amp; !addmodules.isEmpty()) {</span>
<span class="nc" id="L1329">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1330">      opt.createArg().setValue(&quot;--add-modules&quot;);</span>
<span class="nc" id="L1331">      opt.createArg().setValue(</span>
<span class="nc" id="L1332">          addmodules.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
<span class="nc" id="L1334">  }</span>

  /**
   * Process options.
   *
   * @param cmdLine the command line builder
   */
  private void processOptions(final CommandLineBuilder cmdLine) {
<span class="nc" id="L1342">    CommandLineOption opt = null;</span>
    // output
<span class="nc" id="L1344">    opt = cmdLine.createOpt();</span>
<span class="nc" id="L1345">    opt.createArg().setValue(&quot;--output&quot;);</span>
<span class="nc" id="L1346">    opt.createArg().setFile(output);</span>
    // saveopts
<span class="nc bnc" id="L1348" title="All 2 branches missed.">    if (saveopts != null) {</span>
<span class="nc" id="L1349">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1350">      opt.createArg().setValue(&quot;--save-opts&quot;);</span>
<span class="nc" id="L1351">      opt.createArg().setFile(saveopts);</span>
    }
    // postprocesspath
<span class="nc bnc" id="L1354" title="All 2 branches missed.">    if (postprocesspath != null) {</span>
<span class="nc" id="L1355">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1356">      opt.createArg().setValue(&quot;--post-process-path&quot;);</span>
<span class="nc" id="L1357">      opt.createArg().setFile(postprocesspath);</span>
    }
    // resourceslastsorter
<span class="nc bnc" id="L1360" title="All 2 branches missed.">    if (!StringUtils.isBlank(resourceslastsorter)) {</span>
<span class="nc" id="L1361">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1362">      opt.createArg().setValue(&quot;--resources-last-sorter&quot;);</span>
<span class="nc" id="L1363">      opt.createArg().setValue(StringUtils.stripToEmpty(resourceslastsorter));</span>
    }
    // verbose
<span class="nc bnc" id="L1366" title="All 2 branches missed.">    if (verbose) {</span>
<span class="nc" id="L1367">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1368">      opt.createArg().setValue(&quot;--verbose&quot;);</span>
    }
    // bindservices
<span class="nc bnc" id="L1371" title="All 2 branches missed.">    if (bindservices) {</span>
<span class="nc" id="L1372">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1373">      opt.createArg().setValue(&quot;--bind-services&quot;);</span>
    }
    // noheaderfiles
<span class="nc bnc" id="L1376" title="All 2 branches missed.">    if (noheaderfiles) {</span>
<span class="nc" id="L1377">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1378">      opt.createArg().setValue(&quot;--no-header-files&quot;);</span>
    }
    // nomanpages
<span class="nc bnc" id="L1381" title="All 2 branches missed.">    if (nomanpages) {</span>
<span class="nc" id="L1382">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1383">      opt.createArg().setValue(&quot;--no-man-pages&quot;);</span>
    }
    // ignoresigninginformation
<span class="nc bnc" id="L1386" title="All 2 branches missed.">    if (ignoresigninginformation) {</span>
<span class="nc" id="L1387">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1388">      opt.createArg().setValue(&quot;--ignore-signing-information&quot;);</span>
    }
    // stripdebug
<span class="nc bnc" id="L1391" title="All 2 branches missed.">    if (stripdebug) {</span>
<span class="nc" id="L1392">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1393">      opt.createArg().setValue(&quot;--strip-debug&quot;);</span>
    }
    // stripjavadebugattributes
<span class="nc bnc" id="L1396" title="All 2 branches missed.">    if (stripjavadebugattributes) {</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">      if (toolJavaVersion.atLeast(JavaVersion.JAVA_13)) {</span>
<span class="nc" id="L1398">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1399">        opt.createArg().setValue(&quot;--strip-java-debug-attributes&quot;);</span>
      } else {
<span class="nc" id="L1401">        stripjavadebugattributes = false;</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1403">          getLog().warn(MessageFormat.format(</span>
              &quot;Parameter [{0}] skiped, at least {1} is required to use it&quot;,
              &quot;--strip-java-debug-attributes&quot;,
              JavaVersion.JAVA_13));
        }
      }
    }
    // stripnativecommands
<span class="nc bnc" id="L1411" title="All 2 branches missed.">    if (stripnativecommands) {</span>
<span class="nc" id="L1412">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1413">      opt.createArg().setValue(&quot;--strip-native-commands&quot;);</span>
    }
    // deduplegalnotices
<span class="nc bnc" id="L1416" title="All 2 branches missed.">    if (deduplegalnotices) {</span>
<span class="nc" id="L1417">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1418">      opt.createArg().setValue(</span>
          &quot;--dedup-legal-notices=error-if-not-same-content&quot;);
    }
    // limitmodules
<span class="nc bnc" id="L1422" title="All 4 branches missed.">    if (limitmodules != null &amp;&amp; !limitmodules.isEmpty()) {</span>
<span class="nc" id="L1423">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1424">      opt.createArg().setValue(&quot;--limit-modules&quot;);</span>
<span class="nc" id="L1425">      opt.createArg().setValue(</span>
<span class="nc" id="L1426">          limitmodules.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
    // suggestproviders
<span class="nc bnc" id="L1429" title="All 4 branches missed.">    if (suggestproviders != null &amp;&amp; !suggestproviders.isEmpty()) {</span>
<span class="nc" id="L1430">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1431">      opt.createArg().setValue(&quot;--suggest-providers&quot;);</span>
<span class="nc" id="L1432">      opt.createArg().setValue(</span>
<span class="nc" id="L1433">          suggestproviders.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
    // endian
<span class="nc bnc" id="L1436" title="All 4 branches missed.">    if (endian != null &amp;&amp; !endian.equals(Endian.NATIVE)) {</span>
<span class="nc" id="L1437">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1438">      opt.createArg().setValue(&quot;--endian&quot;);</span>
<span class="nc" id="L1439">      opt.createArg().setValue(endian.toString().toLowerCase(Locale.ROOT));</span>
    }
    // disableplugins
<span class="nc bnc" id="L1442" title="All 2 branches missed.">    if (disableplugins != null) {</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">      for (final String plugin : disableplugins) {</span>
<span class="nc" id="L1444">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1445">        opt.createArg().setValue(&quot;--disable-plugin&quot;);</span>
<span class="nc" id="L1446">        opt.createArg().setValue(plugin);</span>
<span class="nc" id="L1447">      }</span>
    }
    // includelocales
<span class="nc bnc" id="L1450" title="All 4 branches missed.">    if (includelocales != null &amp;&amp; !includelocales.isEmpty()) {</span>
<span class="nc" id="L1451">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1452">      opt.createArg().setValue(</span>
<span class="nc" id="L1453">          includelocales.stream()</span>
<span class="nc" id="L1454">              .collect(Collectors.joining(&quot;,&quot;, &quot;--include-locales=&quot;, &quot;&quot;)));</span>
    }
    // excludejmodsection
<span class="nc bnc" id="L1457" title="All 2 branches missed.">    if (excludejmodsection != null) {</span>
<span class="nc" id="L1458">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1459">      opt.createArg().setValue(&quot;--exclude-jmod-section=&quot;</span>
<span class="nc" id="L1460">          + excludejmodsection.toString().toLowerCase(Locale.ROOT));</span>
    }
    // generatejliclasses
<span class="nc bnc" id="L1463" title="All 2 branches missed.">    if (generatejliclasses != null) {</span>
<span class="nc" id="L1464">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1465">      opt.createArg().setValue(&quot;--generate-jli-classes=@&quot;</span>
<span class="nc" id="L1466">          + generatejliclasses.toString());</span>
    }
    // vm
<span class="nc bnc" id="L1469" title="All 2 branches missed.">    if (vm != null) {</span>
<span class="nc" id="L1470">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1471">      opt.createArg().setValue(&quot;--vm=&quot;</span>
<span class="nc" id="L1472">          + vm.toString().toLowerCase(Locale.ROOT));</span>
    }
    // launcher
<span class="nc bnc" id="L1475" title="All 2 branches missed.">    if (launcher != null) {</span>
<span class="nc" id="L1476">      final String launcherCommand =</span>
<span class="nc" id="L1477">          StringUtils.stripToEmpty(launcher.getCommand());</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">      if (!StringUtils.isBlank(launcherCommand)) {</span>
<span class="nc" id="L1479">        final String launcherModule =</span>
<span class="nc" id="L1480">            StringUtils.stripToEmpty(launcher.getMainModule());</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">        if (!StringUtils.isBlank(launcherModule)) {</span>
<span class="nc" id="L1482">          opt = cmdLine.createOpt();</span>
<span class="nc" id="L1483">          opt.createArg().setValue(&quot;--launcher&quot;);</span>
<span class="nc" id="L1484">          final String launcherClass =</span>
<span class="nc" id="L1485">              StringUtils.stripToEmpty(launcher.getMainClass());</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">          if (StringUtils.isBlank(launcherClass)) {</span>
<span class="nc" id="L1487">            opt.createArg().setValue(launcherCommand + &quot;=&quot;</span>
                + launcherModule);
          } else {
<span class="nc" id="L1490">            opt.createArg().setValue(launcherCommand + &quot;=&quot;</span>
                + launcherModule + &quot;/&quot; + launcherClass);
          }
        }
      }
    }
    // compress
<span class="nc bnc" id="L1497" title="All 2 branches missed.">    if (compress != null) {</span>
<span class="nc" id="L1498">      final Compression compression = compress.getCompression();</span>
<span class="nc" id="L1499">      final List&lt;String&gt; filters = compress.getFilters();</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">      if (compression != null) {</span>
<span class="nc" id="L1501">        final StringBuilder option = new StringBuilder(&quot;--compress=&quot;);</span>
<span class="nc" id="L1502">        option.append(compression.getValue());</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">        if (filters != null) {</span>
<span class="nc" id="L1504">          option.append(filters.stream()</span>
<span class="nc" id="L1505">              .collect(Collectors.joining(&quot;,&quot;, &quot;:filter=&quot;, &quot;&quot;)));</span>
        }
<span class="nc" id="L1507">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1508">        opt.createArg().setValue(option.toString());</span>
      }
    }
    // orderresources
<span class="nc bnc" id="L1512" title="All 4 branches missed.">    if (orderresources != null &amp;&amp; !orderresources.isEmpty()) {</span>
<span class="nc" id="L1513">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1514">      opt.createArg().setValue(orderresources.stream()</span>
<span class="nc" id="L1515">          .collect(Collectors.joining(&quot;,&quot;, &quot;--order-resources=&quot;, &quot;&quot;)));</span>
    }
    // excluderesources
<span class="nc bnc" id="L1518" title="All 4 branches missed.">    if (excluderesources != null &amp;&amp; !excluderesources.isEmpty()) {</span>
<span class="nc" id="L1519">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1520">      opt.createArg().setValue(excluderesources.stream()</span>
<span class="nc" id="L1521">          .collect(Collectors.joining(&quot;,&quot;, &quot;--exclude-resources=&quot;, &quot;&quot;)));</span>
    }
    // excludefiles
<span class="nc bnc" id="L1524" title="All 4 branches missed.">    if (excludefiles != null &amp;&amp; !excludefiles.isEmpty()) {</span>
<span class="nc" id="L1525">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1526">      opt.createArg().setValue(excludefiles.stream()</span>
<span class="nc" id="L1527">          .collect(Collectors.joining(&quot;,&quot;, &quot;--exclude-files=&quot;, &quot;&quot;)));</span>
    }
    // releaseinfo
<span class="nc bnc" id="L1530" title="All 2 branches missed.">    if (releaseinfo != null) {</span>
<span class="nc" id="L1531">      final StringBuilder option = new StringBuilder();</span>
<span class="nc" id="L1532">      final File releaseinfofile = releaseinfo.getFile();</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">      if (releaseinfofile != null) {</span>
<span class="nc" id="L1534">        option.append(releaseinfofile.toString());</span>
      }
<span class="nc" id="L1536">      final Map&lt;String, String&gt; adds = releaseinfo.getAdds();</span>
<span class="nc bnc" id="L1537" title="All 4 branches missed.">      if (adds != null &amp;&amp; !adds.entrySet().isEmpty()) {</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">        if (option.length() != 0) {</span>
<span class="nc" id="L1539">          option.append(':');</span>
        }
<span class="nc" id="L1541">        option.append(adds.entrySet().stream()</span>
<span class="nc bnc" id="L1542" title="All 4 branches missed.">            .filter(add -&gt; add != null &amp;&amp; !StringUtils.isBlank(add.getKey()))</span>
<span class="nc" id="L1543">            .map(add -&gt; StringUtils.stripToEmpty(add.getKey()) + &quot;=&quot;</span>
<span class="nc" id="L1544">                + StringUtils.stripToEmpty(add.getValue()))</span>
<span class="nc" id="L1545">            .collect(Collectors.joining(&quot;:&quot;, &quot;add:&quot;, &quot;&quot;)));</span>
      }
<span class="nc" id="L1547">      final Map&lt;String, String&gt; dels = releaseinfo.getDels();</span>
<span class="nc bnc" id="L1548" title="All 4 branches missed.">      if (dels != null &amp;&amp; !dels.entrySet().isEmpty()) {</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">        if (option.length() != 0) {</span>
<span class="nc" id="L1550">          option.append(':');</span>
        }
<span class="nc" id="L1552">        option.append(dels.entrySet().stream()</span>
<span class="nc bnc" id="L1553" title="All 4 branches missed.">            .filter(del -&gt; del != null &amp;&amp; !StringUtils.isBlank(del.getKey()))</span>
<span class="nc" id="L1554">            .map(del -&gt; StringUtils.stripToEmpty(del.getKey()))</span>
<span class="nc" id="L1555">            .collect(Collectors.joining(&quot;:&quot;, &quot;del:&quot;, &quot;&quot;)));</span>
      }
<span class="nc" id="L1557">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1558">      opt.createArg().setValue(&quot;--release-info=&quot; + option.toString());</span>
    }
<span class="nc" id="L1560">  }</span>

  /**
   * Copy files (only files, not directories) to the specified directory.
   *
   * @param files the list of files
   * @param dir the destination directory
   *
   * @throws MojoExecutionException if any errors occurred while copying a file
   */
  private void copyFiles(final List&lt;File&gt; files, final File dir)
      throws MojoExecutionException {
<span class="nc bnc" id="L1572" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1573">      getLog().debug(MessageFormat.format(&quot;Copy files to: [{0}]&quot;, dir));</span>
    }
<span class="nc bnc" id="L1575" title="All 2 branches missed.">    for (final File file : files) {</span>
      try {
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        if (file.exists()) {</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">          if (file.isDirectory()) {</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1580">              getLog().debug(MessageFormat.format(&quot;Skiped directory: [{0}]&quot;,</span>
                  file));
            }
          } else {
<span class="nc" id="L1584">            FileUtils.copyFileToDirectory(file, dir);</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1586">              getLog().debug(MessageFormat.format(&quot;Copied file: [{0}]&quot;, file));</span>
            }
          }
        }
<span class="nc" id="L1590">      } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">        if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1592">          getLog().error(MessageFormat.format(&quot;Unable to copy file: [{0}]&quot;,</span>
              file), ex);
        }
<span class="nc" id="L1595">        throw new MojoExecutionException(MessageFormat.format(</span>
            &quot;Error: Unable to copy file: [{0}]&quot;, file), ex);
<span class="nc" id="L1597">      }</span>
<span class="nc" id="L1598">    }</span>
<span class="nc" id="L1599">  }</span>

  /**
   * Process launcher scripts.
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processLauncherScripts() throws MojoExecutionException {
<span class="nc bnc" id="L1607" title="All 2 branches missed.">    if (launcher == null) {</span>
<span class="nc" id="L1608">      return;</span>
    }

<span class="nc" id="L1611">    final String scriptName = StringUtils.stripToEmpty(launcher.getCommand());</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">    if (StringUtils.isBlank(scriptName)) {</span>
<span class="nc" id="L1613">      return;</span>
    }

<span class="nc" id="L1616">    final Path nixScript = output.toPath().resolve(&quot;bin/&quot; + scriptName);</span>
<span class="nc" id="L1617">    final Path winScript = output.toPath().resolve(&quot;bin/&quot; + scriptName</span>
        + &quot;.bat&quot;);

<span class="nc bnc" id="L1620" title="All 2 branches missed.">    if (stripnativecommands) {</span>
<span class="nc bnc" id="L1621" title="All 4 branches missed.">      if (Files.exists(nixScript) &amp;&amp; !Files.isDirectory(nixScript)) {</span>
        try {
<span class="nc" id="L1623">          FileUtils.forceDelete(nixScript.toFile());</span>
<span class="nc" id="L1624">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">          if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1626">            getLog().warn(MessageFormat.format(</span>
                &quot;Unable to delete launcher script: [{0}]&quot;, nixScript));
          }
<span class="nc" id="L1629">        }</span>
      }
<span class="nc bnc" id="L1631" title="All 4 branches missed.">      if (Files.exists(winScript) &amp;&amp; !Files.isDirectory(winScript)) {</span>
        try {
<span class="nc" id="L1633">          FileUtils.forceDelete(winScript.toFile());</span>
<span class="nc" id="L1634">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">          if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1636">            getLog().warn(MessageFormat.format(</span>
                &quot;Unable to delete launcher script: [{0}]&quot;, winScript));
          }
<span class="nc" id="L1639">        }</span>
      }
<span class="nc" id="L1641">      return;</span>
    }

<span class="nc" id="L1644">    final String moduleName = StringUtils.stripToEmpty(</span>
<span class="nc" id="L1645">        launcher.getMainModule());</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">    if (StringUtils.isEmpty(moduleName)) {</span>
<span class="nc" id="L1647">      return;</span>
    }

<span class="nc" id="L1650">    final String mainClassName = StringUtils.stripToEmpty(</span>
<span class="nc" id="L1651">        launcher.getMainClass());</span>

<span class="nc" id="L1653">    final StringBuilder mainName = new StringBuilder(moduleName);</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">    if (!StringUtils.isEmpty(mainClassName)) {</span>
<span class="nc" id="L1655">      mainName</span>
<span class="nc" id="L1656">          .append('/')</span>
<span class="nc" id="L1657">          .append(mainClassName);</span>
    }

<span class="nc" id="L1660">    final String args = StringUtils.stripToEmpty(launcher.getArgs());</span>

<span class="nc" id="L1662">    final String jvmArgs = StringUtils.stripToEmpty(launcher.getJvmArgs());</span>

<span class="nc bnc" id="L1664" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1665">      getLog().debug(System.lineSeparator()</span>
          + &quot;Processing launcher scripts with following variables:&quot;
<span class="nc" id="L1667">          + System.lineSeparator()</span>
<span class="nc" id="L1668">          + MessageFormat.format(&quot;  - moduleName = [{0}]&quot;, moduleName)</span>
<span class="nc" id="L1669">          + System.lineSeparator()</span>
<span class="nc" id="L1670">          + MessageFormat.format(&quot;  - mainClassName = [{0}]&quot;, mainClassName)</span>
<span class="nc" id="L1671">          + System.lineSeparator()</span>
<span class="nc" id="L1672">          + MessageFormat.format(&quot;  - mainName = [{0}]&quot;, mainName.toString())</span>
<span class="nc" id="L1673">          + System.lineSeparator()</span>
<span class="nc" id="L1674">          + MessageFormat.format(&quot;  - args = [{0}]&quot;, args)</span>
<span class="nc" id="L1675">          + System.lineSeparator()</span>
<span class="nc" id="L1676">          + MessageFormat.format(&quot;  - jvmArgs = [{0}]&quot;, jvmArgs));</span>
    }

<span class="nc" id="L1679">    final Map&lt;String, String&gt; data = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1680">    data.put(&quot;moduleName&quot;, moduleName);</span>
<span class="nc" id="L1681">    data.put(&quot;mainClassName&quot;, mainClassName);</span>
<span class="nc" id="L1682">    data.put(&quot;mainName&quot;, mainName.toString());</span>
<span class="nc" id="L1683">    data.put(&quot;args&quot;, args);</span>
<span class="nc" id="L1684">    data.put(&quot;jvmArgs&quot;, jvmArgs);</span>

<span class="nc" id="L1686">    final File nixTemplate = launcher.getNixTemplate();</span>
<span class="nc bnc" id="L1687" title="All 4 branches missed.">    if (nixTemplate != null &amp;&amp; Files.exists(nixTemplate.toPath())</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">        &amp;&amp; !Files.isDirectory(nixTemplate.toPath())) {</span>
<span class="nc" id="L1689">      createLauncherScript(nixScript, nixTemplate.toPath(), data);</span>
    }

<span class="nc" id="L1692">    final File winTemplate = launcher.getWinTemplate();</span>
<span class="nc bnc" id="L1693" title="All 4 branches missed.">    if (winTemplate != null &amp;&amp; Files.exists(winTemplate.toPath())</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">        &amp;&amp; !Files.isDirectory(winTemplate.toPath())) {</span>
<span class="nc" id="L1695">      createLauncherScript(winScript, winTemplate.toPath(), data);</span>
    }

<span class="nc" id="L1698">  }</span>

  /**
   * Create launcher script.
   *
   * @param script the launcher script file path
   * @param template the launcher template file path
   * @param data the hash map contains variable names and values to substitute
   *
   * @throws MojoExecutionException if any errors occurred while processing
   *                                launcher script files
   */
  private void createLauncherScript(final Path script, final Path template,
      final Map&lt;String, String&gt; data) throws MojoExecutionException {
<span class="nc bnc" id="L1712" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1713">      getLog().debug(System.lineSeparator()</span>
<span class="nc" id="L1714">          + MessageFormat.format(&quot;Fixing launcher script: [{0}]&quot;, script)</span>
<span class="nc" id="L1715">          + System.lineSeparator()</span>
<span class="nc" id="L1716">          + MessageFormat.format(&quot;with template: [{0}]&quot;, template));</span>
    }
<span class="nc" id="L1718">    final StringSubstitutor engine = new StringSubstitutor(data)</span>
<span class="nc" id="L1719">        .setEnableUndefinedVariableException(true)</span>
<span class="nc" id="L1720">        .setPreserveEscapes(true)</span>
<span class="nc" id="L1721">        .setEscapeChar('\\');</span>
    try {
<span class="nc" id="L1723">      Files.write(script,</span>
<span class="nc" id="L1724">          Files.lines(template, sourceEncoding)</span>
<span class="nc" id="L1725">              .map(line -&gt; engine.replace(line).replace(&quot;\\$&quot;, &quot;$&quot;))</span>
<span class="nc" id="L1726">              .collect(Collectors.toList()),</span>
          sourceEncoding);
<span class="nc" id="L1728">    } catch (IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1730">        getLog().error(MessageFormat.format(</span>
            &quot;Variable not found in the launcher template file: [{0}]&quot;,
            template), ex);
      }
<span class="nc" id="L1734">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Variable not found in the launcher template file: [{0}]&quot;, template),
          ex);
<span class="nc" id="L1737">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1739">        getLog().error(MessageFormat.format(</span>
            &quot;Unable to write to the launcher script file: [{0}]&quot;, script), ex);
      }
<span class="nc" id="L1742">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Unable to write to the launcher script file: [{0}]&quot;, script), ex);
<span class="nc" id="L1744">    }</span>
<span class="nc" id="L1745">  }</span>

  /**
   * Execute goal.
   *
   * @throws MojoExecutionException if any errors occurred
   */
  @Override
  public void execute() throws MojoExecutionException {

    // Init
<span class="nc" id="L1756">    init(TOOL_NAME, toolhome, TOOL_HOME_BIN); // from BaseToolMojo</span>

    // Check version
<span class="nc bnc" id="L1759" title="All 2 branches missed.">    if (!toolJavaVersion.atLeast(JavaVersion.JAVA_9)) {</span>
<span class="nc" id="L1760">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: At least {0} is required to use [{1}]&quot;, JavaVersion.JAVA_9,
          TOOL_NAME));
    }

    // Create mods directory
    try {
<span class="nc" id="L1767">      FileUtils.forceMkdir(modsdir);</span>
<span class="nc" id="L1768">    } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc" id="L1769">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to create mods directory: [{0}]&quot;, modsdir), ex);
<span class="nc" id="L1771">    }</span>

    // Create libs directory
    try {
<span class="nc" id="L1775">      FileUtils.forceMkdir(libsdir);</span>
<span class="nc" id="L1776">    } catch (IOException | IllegalArgumentException ex) {</span>
<span class="nc" id="L1777">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to create libs directory: [{0}]&quot;, libsdir), ex);
<span class="nc" id="L1779">    }</span>

    // Delete image output directory if it exists
<span class="nc bnc" id="L1782" title="All 2 branches missed.">    if (getLog().isInfoEnabled()) {</span>
<span class="nc" id="L1783">      getLog().info(MessageFormat.format(</span>
          &quot;Set image output directory to: [{0}]&quot;, output));
    }
<span class="nc bnc" id="L1786" title="All 4 branches missed.">    if (output.exists() &amp;&amp; output.isDirectory()) {</span>
      try {
<span class="nc" id="L1788">        FileUtils.deleteDirectory(output);</span>
<span class="nc" id="L1789">      } catch (IOException ex) {</span>
<span class="nc" id="L1790">        throw new MojoExecutionException(MessageFormat.format(</span>
            &quot;Error: Unable to delete image output directory: [{0}]&quot;, output),
            ex);
<span class="nc" id="L1793">      }</span>
    }

    // Resolve and fetch project dependencies
<span class="nc" id="L1797">    projectDependencies = resolveDependencies();</span>
<span class="nc" id="L1798">    mainModuleDescriptor = fetchMainModuleDescriptor();</span>
<span class="nc" id="L1799">    classpathElements = fetchClasspathElements();</span>
<span class="nc" id="L1800">    modulepathElements = fetchModulepathElements();</span>
<span class="nc" id="L1801">    pathExceptions = fetchPathExceptions();</span>
<span class="nc bnc" id="L1802" title="All 4 branches missed.">    if (!pathExceptions.isEmpty() &amp;&amp; getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1803">      getLog().warn(&quot;Found path exceptions: &quot; + pathExceptions.size()</span>
<span class="nc" id="L1804">          + System.lineSeparator()</span>
<span class="nc" id="L1805">          + pathExceptions.entrySet().stream()</span>
<span class="nc" id="L1806">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc" id="L1807">                  + System.lineSeparator()</span>
<span class="nc" id="L1808">                  + entry.getValue())</span>
<span class="nc" id="L1809">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }

    // copy dependencies
<span class="nc" id="L1813">    copyFiles(modulepathElements, modsdir);</span>
<span class="nc" id="L1814">    copyFiles(classpathElements, libsdir);</span>

    // Build command line and populate the list of the command options
<span class="nc" id="L1817">    final CommandLineBuilder cmdLineBuilder = new CommandLineBuilder();</span>
<span class="nc" id="L1818">    cmdLineBuilder.setExecutable(toolExecutable.toString());</span>
<span class="nc" id="L1819">    processOptions(cmdLineBuilder);</span>
<span class="nc" id="L1820">    processModules(cmdLineBuilder);</span>
<span class="nc" id="L1821">    final List&lt;String&gt; optsLines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1822">    optsLines.add(&quot;# &quot; + TOOL_NAME);</span>
<span class="nc" id="L1823">    optsLines.addAll(cmdLineBuilder.buildOptionList());</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1825">      getLog().debug(optsLines.stream()</span>
<span class="nc" id="L1826">          .collect(Collectors.joining(System.lineSeparator(),</span>
<span class="nc" id="L1827">              System.lineSeparator(), &quot;&quot;)));</span>
    }

    // Save the list of command options to the file
    // will be used in the tool command line
<span class="nc" id="L1832">    final Path cmdOptsPath = buildDir.toPath().resolve(OPTS_FILE);</span>
    try {
<span class="nc" id="L1834">      Files.write(cmdOptsPath, optsLines, sourceEncoding);</span>
<span class="nc" id="L1835">    } catch (IOException ex) {</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1837">        getLog().error(MessageFormat.format(</span>
            &quot;Unable to write command options to file: [{0}]&quot;, cmdOptsPath), ex);
      }
<span class="nc" id="L1840">    }</span>

    // Prepare command line with command options
    // specified in the file created early
<span class="nc" id="L1844">    final Commandline cmdLine = new Commandline();</span>
<span class="nc" id="L1845">    cmdLine.setExecutable(toolExecutable.toString());</span>
<span class="nc" id="L1846">    cmdLine.createArg().setValue(&quot;@&quot; + cmdOptsPath.toString());</span>

    // Execute command line
<span class="nc" id="L1849">    int exitCode = 0;</span>
    try {
<span class="nc" id="L1851">      exitCode = execCmdLine(cmdLine); // from BaseToolMojo</span>
<span class="nc" id="L1852">    } catch (CommandLineException ex) {</span>
<span class="nc" id="L1853">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to execute [{0}] tool&quot;, TOOL_NAME), ex);
<span class="nc" id="L1855">    }</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">    if (exitCode != 0) {</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1858">        getLog().error(System.lineSeparator()</span>
            + &quot;Command options was: &quot;
<span class="nc" id="L1860">            + System.lineSeparator()</span>
<span class="nc" id="L1861">            + optsLines.stream()</span>
<span class="nc" id="L1862">                .collect(Collectors.joining(System.lineSeparator())));</span>
      }
<span class="nc" id="L1864">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Tool execution failed [{0}] with exit code: {1}&quot;, TOOL_NAME,
<span class="nc" id="L1866">          exitCode));</span>
    }

    // Process launcher scripts
<span class="nc" id="L1870">    processLauncherScripts();</span>

    // Delete temporary file
    try {
<span class="nc" id="L1874">      FileUtils.forceDeleteOnExit(cmdOptsPath.toFile());</span>
<span class="nc" id="L1875">    } catch (IOException ex) {</span>
<span class="nc" id="L1876">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to delete temporary file: [{0}]&quot;, cmdOptsPath), ex);
<span class="nc" id="L1878">    }</span>

<span class="nc" id="L1880">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>